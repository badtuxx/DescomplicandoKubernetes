
<!DOCTYPE HTML>
<html lang="pt" >
    <head>
        <meta charset="UTF-8">
        <title>Descomplicando Kubernetes dia 1 Â· HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.6.20">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../day-2/" />
    
    
    <link rel="prev" href="../" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escreva para pesquisar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Sobre</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    IntroduÃ§Ã£o
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">CapÃ­tulos</li>
        
        
    
        <li class="chapter active" data-level="2.1" data-path="./">
            
                <a href="./">
            
                    
                    Descomplicando Kubernetes dia 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../day-2/">
            
                <a href="../day-2/">
            
                    
                    Descomplicando Kubernetes dia 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../day-3/">
            
                <a href="../day-3/">
            
                    
                    Descomplicando Kubernetes dia 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../day-4/">
            
                <a href="../day-4/">
            
                    
                    Descomplicando Kubernetes dia 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../day-5/">
            
                <a href="../day-5/">
            
                    
                    Descomplicando Kubernetes dia 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="../day-6/">
            
                <a href="../day-6/">
            
                    
                    Descomplicando Kubernetes dia 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="../day-7/">
            
                <a href="../day-7/">
            
                    
                    Descomplicando Kubernetes dia 7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.8" data-path="../day-8/">
            
                <a href="../day-8/">
            
                    
                    Descomplicando Kubernetes dia 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.9" data-path="../day-9/">
            
                <a href="../day-9/">
            
                    
                    Descomplicando Kubernetes dia 9
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.10" data-path="../day-10/">
            
                <a href="../day-10/">
            
                    
                    Descomplicando Kubernetes dia 10
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.11" data-path="../day-11/">
            
                <a href="../day-11/">
            
                    
                    Descomplicando Kubernetes dia 11
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.12" data-path="../day-12/">
            
                <a href="../day-12/">
            
                    
                    Descomplicando Kubernetes dia 12
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.13" data-path="../day-13/">
            
                <a href="../day-13/">
            
                    
                    Descomplicando Kubernetes dia 13
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.14" data-path="../day-14/">
            
                <a href="../day-14/">
            
                    
                    Descomplicando Kubernetes dia 14
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.15" data-path="../day-15/">
            
                <a href="../day-15/">
            
                    
                    Descomplicando Kubernetes dia 15
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Contribuir</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../CONTRIBUTING.html">
            
                <a href="../CONTRIBUTING.html">
            
                    
                    Como ajudar
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Publicado com HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Descomplicando Kubernetes dia 1</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="descomplicando-o-kubernetes">Descomplicando o Kubernetes</h1>
<p>Â </p>
<h2 id="day-1-o-que-Ã©-o-kubernetes">DAY-1: O que Ã© o Kubernetes?</h2>
<p>Â </p>
<h3 id="conteÃºdo-do-day-1">ConteÃºdo do Day-1</h3>
<ul>
<li><a href="#descomplicando-o-kubernetes">Descomplicando o Kubernetes</a><ul>
<li><a href="#day-1">DAY-1</a><ul>
<li><a href="#o-que-iremos-ver-hoje">O que iremos ver hoje?</a></li>
<li><a href="#inicio-da-aula-do-day-1">Inicio da aula do Day-1</a></li>
<li><a href="#qual-distro-gnulinux-devo-usar">Qual distro GNU/Linux devo usar?</a></li>
<li><a href="#alguns-sites-que-devemos-visitar">Alguns sites que devemos visitar</a></li>
<li><a href="#o-container-engine">O Container Engine</a><ul>
<li><a href="#oci---open-container-initiative">OCI - Open Container Initiative</a></li>
<li><a href="#o-container-runtime">O Container Runtime</a></li>
</ul>
</li>
<li><a href="#o-que-Ã©-o-kubernetes">O que Ã© o Kubernetes?</a></li>
<li><a href="#arquitetura-do-k8s">Arquitetura do k8s</a></li>
<li><a href="#portas-que-devemos-nos-preocupar">Portas que devemos nos preocupar</a></li>
<li><a href="#conceitos-chave-do-k8s">Conceitos-chave do k8s</a></li>
<li><a href="#instalando-e-customizando-o-kubectl">Instalando e customizando o Kubectl</a><ul>
<li><a href="#instalaÃ§Ã£o-do-kubectl-no-gnulinux">InstalaÃ§Ã£o do Kubectl no GNU/Linux</a></li>
<li><a href="#instalaÃ§Ã£o-do-kubectl-no-macos">InstalaÃ§Ã£o do Kubectl no MacOS</a></li>
<li><a href="#instalaÃ§Ã£o-do-kubectl-no-windows">InstalaÃ§Ã£o do Kubectl no Windows</a></li>
</ul>
</li>
<li><a href="#customizando-o-kubectl">Customizando o kubectl</a><ul>
<li><a href="#auto-complete">Auto-complete</a></li>
<li><a href="#criando-um-alias-para-o-kubectl">Criando um alias para o kubectl</a></li>
</ul>
</li>
<li><a href="#criando-um-cluster-kubernetes">Criando um cluster Kubernetes</a></li>
<li><a href="#criando-o-cluster-em-sua-mÃ¡quina-local">Criando o cluster em sua mÃ¡quina local</a><ul>
<li><a href="#minikube">Minikube</a><ul>
<li><a href="#requisitos-bÃ¡sicos">Requisitos bÃ¡sicos</a></li>
<li><a href="#instalaÃ§Ã£o-do-minikube-no-gnulinux">InstalaÃ§Ã£o do Minikube no GNU/Linux</a></li>
<li><a href="#instalaÃ§Ã£o-do-minikube-no-macos">InstalaÃ§Ã£o do Minikube no MacOS</a></li>
<li><a href="#instalaÃ§Ã£o-do-minikube-no-microsoft-windows">InstalaÃ§Ã£o do Minikube no Microsoft Windows</a></li>
<li><a href="#iniciando-parando-e-excluindo-o-minikube">Iniciando, parando e excluindo o Minikube</a></li>
<li><a href="#certo-e-como-eu-sei-que-estÃ¡-tudo-funcionando-como-deveria">Certo, e como eu sei que estÃ¡ tudo funcionando como deveria?</a></li>
<li><a href="#ver-detalhes-sobre-o-cluster">Ver detalhes sobre o cluster</a></li>
<li><a href="#descobrindo-o-endereÃ§o-do-minikube">Descobrindo o endereÃ§o do Minikube</a></li>
<li><a href="#acessando-a-mÃ¡quina-do-minikube-via-ssh">Acessando a mÃ¡quina do Minikube via SSH</a></li>
<li><a href="#dashboard-do-minikube">Dashboard do Minikube</a></li>
<li><a href="#logs-do-minikube">Logs do Minikube</a></li>
<li><a href="#remover-o-cluster">Remover o cluster</a></li>
</ul>
</li>
<li><a href="#kind">Kind</a><ul>
<li><a href="#instalaÃ§Ã£o-no-gnulinux">InstalaÃ§Ã£o no GNU/Linux</a></li>
<li><a href="#instalaÃ§Ã£o-no-macos">InstalaÃ§Ã£o no MacOS</a></li>
<li><a href="#instalaÃ§Ã£o-no-windows">InstalaÃ§Ã£o no Windows</a><ul>
<li><a href="#instalaÃ§Ã£o-no-windows-via-chocolatey">InstalaÃ§Ã£o no Windows via Chocolatey</a></li>
</ul>
</li>
<li><a href="#criando-um-cluster-com-o-kind">Criando um cluster com o Kind</a></li>
<li><a href="#criando-um-cluster-com-mÃºltiplos-nÃ³s-locais-com-o-kind">Criando um cluster com mÃºltiplos nÃ³s locais com o Kind</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#primeiros-passos-no-k8s">Primeiros passos no k8s</a><ul>
<li><a href="#verificando-os-namespaces-e-pods">Verificando os namespaces e pods</a></li>
<li><a href="#executando-nosso-primeiro-pod-no-k8s">Executando nosso primeiro pod no k8s</a></li>
<li><a href="#executando-nosso-primeiro-pod-no-k8s-1">Executando nosso primeiro pod no k8s</a><ul>
<li><a href="#expondo-o-pod-e-criando-um-service">Expondo o pod e criando um Service</a></li>
<li><a href="#limpando-tudo-e-indo-para-casa">Limpando tudo e indo para casa</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Â </p>
<h3 id="o-que-iremos-ver-hoje">O que iremos ver hoje?</h3>
<p>Durante o Day-1 exploraremos o conceito de containers, discutiremos a relevÃ¢ncia do container runtime e do container engine. AlÃ©m disso, vamos entender o que Ã© o Kubernetes e sua arquitetura, falaremos sobre o control plane, workers, apiserver, scheduler, controller e muito mais!
SerÃ¡ aqui que iremos criar o nosso primeiro cluster Kubernetes e realizar o deploy de um pod do Nginx. 
O Day-1 Ã© para que vocÃª possa se sentir mais confortÃ¡vel com o Kubernetes e seus conceitos iniciais.
Â </p>
<h3 id="inicio-da-aula-do-day-1">Inicio da aula do Day-1</h3>
<p>Â </p>
<h3 id="qual-distro-gnulinux-devo-usar">Qual distro GNU/Linux devo usar?</h3>
<p>Considerando que ferramentas essenciais, como o <code>systemd</code> e <code>journald</code>, agora sÃ£o amplamente adotadas como padrÃ£o nas principais distribuiÃ§Ãµes disponÃ­veis, como Ubuntu, Debian, CentOS, entre outras, vocÃª nÃ£o deverÃ¡ enfrentar dificuldades ao seguir o treinamento utilizando qualquer uma delas.
Â </p>
<h3 id="alguns-sites-que-devemos-visitar">Alguns sites que devemos visitar</h3>
<p>Abaixo temos os sites oficiais do projeto do Kubernetes:</p>
<ul>
<li><p><a href="https://kubernetes.io" target="_blank">https://kubernetes.io</a></p>
</li>
<li><p><a href="https://github.com/kubernetes/kubernetes/" target="_blank">https://github.com/kubernetes/kubernetes/</a></p>
</li>
<li><p><a href="https://github.com/kubernetes/kubernetes/issues" target="_blank">https://github.com/kubernetes/kubernetes/issues</a></p>
</li>
</ul>
<p>Â 
Abaixo temos as pÃ¡ginas oficiais das certificaÃ§Ãµes do Kubernetes (CKA, CKAD e CKS):</p>
<ul>
<li><p><a href="https://www.cncf.io/certification/cka/" target="_blank">https://www.cncf.io/certification/cka/</a></p>
</li>
<li><p><a href="https://www.cncf.io/certification/ckad/" target="_blank">https://www.cncf.io/certification/ckad/</a></p>
</li>
<li><p><a href="https://www.cncf.io/certification/cks/" target="_blank">https://www.cncf.io/certification/cks/</a></p>
</li>
</ul>
<p>Â </p>
<h3 id="o-container-engine">O Container Engine</h3>
<p>Antes de comeÃ§ar a falar um pouco mais sobre o Kubernetes, nÃ³s primeiro precisamos entender alguns componentes que sÃ£o importantes no ecossistema do Kubernetes, um desses componentes Ã© o Container Engine. </p>
<p>O <em>Container Engine</em> Ã© o responsÃ¡vel por gerenciar as imagens e volumes, ele Ã© o responsÃ¡vel por garantir que os os recursos utilizados pelos containers estÃ£o devidamente isolados, a vida do container, storage, rede, etc.</p>
<p>AtÃ© pouco tempo atrÃ¡s tinhamos somente o Docker para esse papel. Mas hoje jÃ¡ temos diversas opÃ§Ãµes para se utilizar como <em>Container Engine</em>.</p>
<p>OpÃ§Ãµes como o Docker, o CRI-O e o Podman sÃ£o bem conhecidas e preparadas para o ambiente produtivo. O Docker, Ã© o Container Engine mais popular e ele utiliza como Container Runtime o containerd.</p>
<p>Container Runtime? O que Ã© isso?</p>
<p>Calma que vou te explicar jÃ¡ jÃ¡, mas antes temos que falar sobre a OCI. :)</p>
<p>Â </p>
<h4 id="oci---open-container-initiative">OCI - Open Container Initiative</h4>
<p>A OCI Ã© uma organizaÃ§Ã£o sem fins lucrativos que tem como objetivo padronizar a criaÃ§Ã£o de containers, para que possam ser executados em qualquer ambiente. A OCI foi fundada em 2015 pela Docker, CoreOS, Google, IBM, Microsoft, Red Hat e VMware e hoje faz parte da Linux Foundation.</p>
<p>O runc, principal projeto desenvolvido pela OCI, Ã© um container runtime de baixo nÃ­vel amplamente utilizado por diversos Container Engines, incluindo o Docker. Este projeto, totalmente open source, Ã© escrito em Go e seu cÃ³digo fonte pode ser acessado no GitHub.</p>
<p>Agora sim jÃ¡ podemos falar sobre o que Ã© o Container Runtime.</p>
<p>Â </p>
<h4 id="o-container-runtime">O Container Runtime</h4>
<p>Para que seja possÃ­vel executar os containers nos nÃ³s Ã© necessÃ¡rio ter um <em>Container Runtime</em> instalado em cada um desses nÃ³s.</p>
<p>O <em>Container Runtime</em> Ã© o responsÃ¡vel por executar os containers nos nÃ³s. Quando vocÃª estÃ¡ utilizando ferramentas como Docker ou Podman para executar containers em sua mÃ¡quina, por exemplo, vocÃª estÃ¡ fazendo uso de algum <em>Container Runtime</em>, ou melhor, o seu Container Engine estÃ¡ fazendo uso de algum <em>Container Runtime</em>.</p>
<p>Temos trÃªs tipos de <em>Container Runtime</em>:</p>
<ul>
<li><p>Low-level: sÃ£o os <em>Container Runtime</em> que sÃ£o executados diretamente pelo Kernel, como o runc, o crun e o runsc.</p>
</li>
<li><p>High-level: sÃ£o os <em>Container Runtime</em> que sÃ£o executados por um <em>Container Engine</em>, como o containerd, o CRI-O e o Podman.</p>
</li>
<li><p>Sandbox e Virtualized: sÃ£o os <em>Container Runtime</em> que sÃ£o executados por um <em>Container Engine</em> e que sÃ£o responsÃ¡veis por executar containers de forma segura. O tipo Sandbox Ã© executado em unikernels ou utilizando algum proxy para fazer a comunicaÃ§Ã£o com o Kernel. O gVisor Ã© um exemplo de <em>Container Runtime</em> do tipo Sandbox. JÃ¡ o tipo Virtualized Ã© executado em mÃ¡quinas virtuais. A performance aqui Ã© um pouco menor do que quando executado nativamente. O Kata Containers Ã© um exemplo de <em>Container Runtime</em> do tipo Virtualized.</p>
</li>
</ul>
<p>Â </p>
<h3 id="o-que-Ã©-o-kubernetes">O que Ã© o Kubernetes?</h3>
<p><strong>VersÃ£o resumida:</strong></p>
<p>O projeto Kubernetes foi desenvolvido pela Google, em meados de 2014, para atuar como um orquestrador de contÃªineres para a empresa. O Kubernetes (k8s), cujo termo em Grego significa &quot;timoneiro&quot;, Ã© um projeto <em>open source</em> que conta com <em>design</em> e desenvolvimento baseados no projeto Borg, que tambÃ©m Ã© da Google <a href="https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/" target="_blank">1</a>. Alguns outros produtos disponÃ­veis no mercado, tais como o Apache Mesos e o Cloud Foundry, tambÃ©m surgiram a partir do projeto Borg.</p>
<p>Como Kubernetes Ã© uma palavra difÃ­cil de se pronunciar - e de se escrever - a comunidade simplesmente o apelidou de <strong>k8s</strong>, seguindo o padrÃ£o <a href="http://www.i18nguy.com/origini18n.html" target="_blank">i18n</a> (a letra &quot;k&quot; seguida por oito letras e o &quot;s&quot; no final), pronunciando-se simplesmente &quot;kates&quot;.</p>
<p><strong>VersÃ£o longa:</strong></p>
<p>Praticamente todo software desenvolvido na Google Ã© executado em contÃªiner <a href="https://www.enterpriseai.news/2014/05/28/google-runs-software-containers/" target="_blank">2</a>. A Google jÃ¡ gerencia contÃªineres em larga escala hÃ¡ mais de uma dÃ©cada, quando nÃ£o se falava tanto sobre isso. Para atender a demanda interna, alguns desenvolvedores do Google construÃ­ram trÃªs sistemas diferentes de gerenciamento de contÃªineres: <strong>Borg</strong>, <strong>Omega</strong> e <strong>Kubernetes</strong>. Cada sistema teve o desenvolvimento influenciado pelo antecessor, embora fosse desenvolvido por diferentes razÃµes.</p>
<p>O primeiro sistema de gerenciamento de contÃªineres desenvolvido no Google foi o Borg, construÃ­do para gerenciar serviÃ§os de longa duraÃ§Ã£o e jobs em lote, que anteriormente eram tratados por dois sistemas:  <strong>Babysitter</strong> e <strong>Global Work Queue</strong>. O Ãºltimo influenciou fortemente a arquitetura do Borg, mas estava focado em execuÃ§Ã£o de jobs em lote. O Borg continua sendo o principal sistema de gerenciamento de contÃªineres dentro do Google por causa de sua escala, variedade de recursos e robustez extrema.</p>
<p>O segundo sistema foi o Omega, descendente do Borg. Ele foi impulsionado pelo desejo de melhorar a engenharia de software do ecossistema Borg. Esse sistema aplicou muitos dos padrÃµes que tiveram sucesso no Borg, mas foi construÃ­do do zero para ter a arquitetura mais consistente. Muitas das inovaÃ§Ãµes do Omega foram posteriormente incorporadas ao Borg.</p>
<p>O terceiro sistema foi o Kubernetes. Concebido e desenvolvido em um mundo onde desenvolvedores externos estavam se interessando em contÃªineres e o Google desenvolveu um negÃ³cio em amplo crescimento atualmente, que Ã© a venda de infraestrutura de nuvem pÃºblica.</p>
<p>O Kubernetes Ã© de cÃ³digo aberto - em contraste com o Borg e o Omega que foram desenvolvidos como sistemas puramente internos do Google. O Kubernetes foi desenvolvido com um foco mais forte na experiÃªncia de desenvolvedores que escrevem aplicativos que sÃ£o executados em um cluster: seu principal objetivo Ã© facilitar a implantaÃ§Ã£o e o gerenciamento de sistemas distribuÃ­dos, enquanto se beneficia do melhor uso de recursos de memÃ³ria e processamento que os contÃªineres possibilitam.</p>
<p>Estas informaÃ§Ãµes foram extraÃ­das e adaptadas deste <a href="https://static.googleusercontent.com/media/research.google.com/pt-BR//pubs/archive/44843.pdf" target="_blank">artigo</a>, que descreve as liÃ§Ãµes aprendidas com o desenvolvimento e operaÃ§Ã£o desses sistemas.
Â </p>
<h3 id="arquitetura-do-k8s">Arquitetura do k8s</h3>
<p>Assim como os demais orquestradores disponÃ­veis, o k8s tambÃ©m segue um modelo <em>control plane/workers</em>, constituindo assim um <em>cluster</em>, onde para seu funcionamento Ã© recomendado no mÃ­nimo trÃªs nÃ³s: o nÃ³ <em>control-plane</em>, responsÃ¡vel (por padrÃ£o) pelo gerenciamento do <em>cluster</em>, e os demais como <em>workers</em>, responsÃ¡veis por executar as aplicaÃ§Ãµes.</p>
<p>Ã‰ possÃ­vel criar um cluster Kubernetes rodando em apenas um nÃ³, porÃ©m Ã© recomendado somente para fins de estudos e nunca executado em ambiente produtivo.</p>
<p>Caso vocÃª queira utilizar o Kubernetes em sua mÃ¡quina local, em seu desktop, existem diversas soluÃ§Ãµes que irÃ£o criar um cluster Kubernetes, utilizando mÃ¡quinas virtuais ou o Docker, por exemplo.</p>
<p>Com isso vocÃª poderÃ¡ ter um cluster Kubernetes com diversos nÃ³s, porÃ©m todos eles rodando em sua mÃ¡quina local, em seu desktop.</p>
<p>Alguns exemplos sÃ£o:</p>
<ul>
<li><p><a href="https://kind.sigs.k8s.io/docs/user/quick-start" target="_blank">Kind</a>: Uma ferramenta para execuÃ§Ã£o de contÃªineres Docker que simulam o funcionamento de um cluster Kubernetes. Ã‰ utilizado para fins didÃ¡ticos, de desenvolvimento e testes. O <strong>Kind nÃ£o deve ser utilizado para produÃ§Ã£o</strong>;</p>
</li>
<li><p><a href="https://github.com/kubernetes/minikube" target="_blank">Minikube</a>: ferramenta para implementar um <em>cluster</em> Kubernetes localmente com apenas um nÃ³. Muito utilizado para fins didÃ¡ticos, de desenvolvimento e testes. O <strong>Minikube nÃ£o deve ser utilizado para produÃ§Ã£o</strong>;</p>
</li>
<li><p><a href="https://microk8s.io" target="_blank">MicroK8S</a>: Desenvolvido pela <a href="https://canonical.com" target="_blank">Canonical</a>, mesma empresa que desenvolve o <a href="https://ubuntu.com" target="_blank">Ubuntu</a>. Pode ser utilizado em diversas distribuiÃ§Ãµes e <strong>pode ser utilizado em ambientes de produÃ§Ã£o</strong>, em especial para <em>Edge Computing</em> e IoT (<em>Internet of things</em>);</p>
</li>
<li><p><a href="https://k3s.io" target="_blank">k3s</a>: Desenvolvido pela <a href="https://rancher.com" target="_blank">Rancher Labs</a>, Ã© um concorrente direto do MicroK8s, podendo ser executado inclusive em Raspberry Pi;</p>
</li>
<li><p><a href="https://k0sproject.io" target="_blank">k0s</a>: Desenvolvido pela <a href="https://www.mirantis.com" target="_blank">Mirantis</a>, mesma empresa que adquiriu a parte enterprise do <a href="https://www.docker.com" target="_blank">Docker</a>. Ã‰ uma distribuiÃ§Ã£o do Kubernetes com todos os recursos necessÃ¡rios para funcionar em um Ãºnico binÃ¡rio, que proporciona uma simplicidade na instalaÃ§Ã£o e manutenÃ§Ã£o do cluster. A pronÃºncia Ã© correta Ã© kay-zero-ess e tem por objetivo reduzir o esforÃ§o tÃ©cnico e desgaste na instalaÃ§Ã£o de um cluster Kubernetes, por isso o seu nome faz alusÃ£o a <em>Zero Friction</em>. <strong>O k0s pode ser utilizado em ambientes de produÃ§Ã£o</strong>;</p>
</li>
<li><p><strong>API Server</strong>: Ã‰ um dos principais componentes do k8s. Este componente fornece uma API que utiliza JSON sobre HTTP para comunicaÃ§Ã£o, onde para isto Ã© utilizado principalmente o utilitÃ¡rio <code>kubectl</code>, por parte dos administradores, para a comunicaÃ§Ã£o com os demais nÃ³s. Estas comunicaÃ§Ãµes entre componentes sÃ£o estabelecidas atravÃ©s de requisiÃ§Ãµes <a href="https://restfulapi.net" target="_blank">REST</a>;</p>
</li>
<li><p><strong>etcd</strong>: O etcd Ã© um <em>datastore</em> chave-valor distribuÃ­do que o k8s utiliza para armazenar as especificaÃ§Ãµes, status e configuraÃ§Ãµes do <em>cluster</em>. Todos os dados armazenados dentro do etcd sÃ£o manipulados apenas atravÃ©s da API. Por questÃµes de seguranÃ§a, o etcd Ã© por padrÃ£o executado apenas em nÃ³s classificados como <em>control plane</em> no <em>cluster</em> k8s, mas tambÃ©m podem ser executados em <em>clusters</em> externos, especÃ­ficos para o etcd, por exemplo;</p>
</li>
<li><p><strong>Scheduler</strong>: O <em>scheduler</em> Ã© responsÃ¡vel por selecionar o nÃ³ que irÃ¡ hospedar um determinado <em>pod</em> (a menor unidade de um <em>cluster</em> k8s - nÃ£o se preocupe sobre isso por enquanto, nÃ³s falaremos mais sobre isso mais tarde) para ser executado. Esta seleÃ§Ã£o Ã© feita baseando-se na quantidade de recursos disponÃ­veis em cada nÃ³, como tambÃ©m no estado de cada um dos nÃ³s do <em>cluster</em>, garantindo assim que os recursos sejam bem distribuÃ­dos. AlÃ©m disso, a seleÃ§Ã£o dos nÃ³s, na qual um ou mais pods serÃ£o executados, tambÃ©m pode levar em consideraÃ§Ã£o polÃ­ticas definidas pelo usuÃ¡rio, tais como afinidade, localizaÃ§Ã£o dos dados a serem lidos pelas aplicaÃ§Ãµes, etc;</p>
</li>
<li><p><strong>Controller Manager</strong>: Ã‰ o <em>controller manager</em> quem garante que o <em>cluster</em> esteja no Ãºltimo estado definido no etcd. Por exemplo: se no etcd um <em>deploy</em> estÃ¡ configurado para possuir dez rÃ©plicas de um <em>pod</em>, Ã© o <em>controller manager</em> quem irÃ¡ verificar se o estado atual do <em>cluster</em> corresponde a este estado e, em caso negativo, procurarÃ¡ conciliar ambos;</p>
</li>
<li><p><strong>Kubelet</strong>: O <em>kubelet</em> desempenha o papel de um agente do k8s que Ã© executado nos nÃ³s workers. Em cada nÃ³ worker deverÃ¡ existir um agente Kubelet em execuÃ§Ã£o, encarregado de gerenciar efetivamente os <em>pods</em> direcionados pelo <em>controller</em> do <em>cluster</em> dentro dos nÃ³s. Para isso, o Kubelet pode iniciar, parar e manter os contÃªineres e os pods em funcionamento seguindo as instruÃ§Ãµes fornecidas pelo controlador do cluster;</p>
</li>
<li><p><strong>Kube-proxy</strong>: Age como um <em>proxy</em> e um <em>load balancer</em>. Este componente Ã© responsÃ¡vel por efetuar roteamento de requisiÃ§Ãµes para os <em>pods</em> corretos, como tambÃ©m por cuidar da parte de rede do nÃ³;</p>
</li>
</ul>
<p>Â </p>
<h3 id="portas-que-devemos-nos-preocupar">Portas que devemos nos preocupar</h3>
<p><strong>CONTROL PLANE</strong></p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Direction</th>
<th>Port Range</th>
<th>Purpose</th>
<th>Used By</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>6443*</td>
<td>Kubernetes API server</td>
<td>All</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver, etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10250</td>
<td>Kubelet API</td>
<td>Self, Control plane</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10259</td>
<td>kube-scheduler</td>
<td>Self</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10257</td>
<td>kube-controller-manager</td>
<td>Self</td>
</tr>
</tbody>
</table>
<ul>
<li>Toda porta marcada por * Ã© customizÃ¡vel, vocÃª precisa se certificar que a porta alterada tambÃ©m esteja aberta.</li>
</ul>
<p>Â 
<strong>WORKERS</strong></p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Direction</th>
<th>Port Range</th>
<th>Purpose</th>
<th>Used By</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10250</td>
<td>Kubelet API</td>
<td>Self, Control plane</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>30000-32767</td>
<td>NodePort</td>
<td>Services All</td>
</tr>
</tbody>
</table>
<p>Â </p>
<h3 id="conceitos-chave-do-k8s">Conceitos-chave do k8s</h3>
<p>Ã‰ importante saber que a forma como o k8s gerencia os contÃªineres Ã© ligeiramente diferente de outros orquestradores, como o Docker Swarm, sobretudo devido ao fato de que ele nÃ£o trata os contÃªineres diretamente, mas sim atravÃ©s de <em>pods</em>. Vamos conhecer alguns dos principais conceitos que envolvem o k8s a seguir:</p>
<ul>
<li><p><strong>Pod</strong>: Ã‰ o menor objeto do k8s. Como dito anteriormente, o k8s nÃ£o trabalha com os contÃªineres diretamente, mas organiza-os dentro de <em>pods</em>, que sÃ£o abstraÃ§Ãµes que dividem os mesmos recursos, como endereÃ§os, volumes, ciclos de CPU e memÃ³ria. Um pod pode possuir vÃ¡rios contÃªineres;</p>
</li>
<li><p><strong>Deployment</strong>: Ã‰ um dos principais <em>controllers</em> utilizados. O <em>Deployment</em>, em conjunto com o <em>ReplicaSet</em>, garante que determinado nÃºmero de rÃ©plicas de um pod esteja em execuÃ§Ã£o nos nÃ³s workers do cluster. AlÃ©m disso, o Deployment tambÃ©m Ã© responsÃ¡vel por gerenciar o ciclo de vida das aplicaÃ§Ãµes, onde caracterÃ­sticas associadas a aplicaÃ§Ã£o, tais como imagem, porta, volumes e variÃ¡veis de ambiente, podem ser especificados em arquivos do tipo <em>yaml</em> ou <em>json</em> para posteriormente serem passados como parÃ¢metro para o <code>kubectl</code> executar o deployment. Esta aÃ§Ã£o pode ser executada tanto para criaÃ§Ã£o quanto para atualizaÃ§Ã£o e remoÃ§Ã£o do deployment;</p>
</li>
<li><p><strong>ReplicaSets</strong>: Ã‰ um objeto responsÃ¡vel por garantir a quantidade de pods em execuÃ§Ã£o no nÃ³;</p>
</li>
<li><p><strong>Services</strong>: Ã‰ uma forma de vocÃª expor a comunicaÃ§Ã£o atravÃ©s de um <em>ClusterIP</em>, <em>NodePort</em> ou <em>LoadBalancer</em> para distribuir as requisiÃ§Ãµes entre os diversos Pods daquele Deployment. Funciona como um balanceador de carga.</p>
</li>
</ul>
<h3 id="instalando-e-customizando-o-kubectl">Instalando e customizando o Kubectl</h3>
<h4 id="instalaÃ§Ã£o-do-kubectl-no-gnulinux">InstalaÃ§Ã£o do Kubectl no GNU/Linux</h4>
<p>Vamos instalar o <code>kubectl</code> com os seguintes comandos.</p>
<pre><code>curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
kubectl version --client
</code></pre><p>Â </p>
<h4 id="instalaÃ§Ã£o-do-kubectl-no-macos">InstalaÃ§Ã£o do Kubectl no MacOS</h4>
<p>O <code>kubectl</code> pode ser instalado no MacOS utilizando tanto o <a href="https://brew.sh" target="_blank">Homebrew</a>, quanto o mÃ©todo tradicional. Com o Homebrew jÃ¡ instalado, o kubectl pode ser instalado da seguinte forma.</p>
<pre><code>sudo brew install kubectl

kubectl version --client
</code></pre><p>Â 
Ou:</p>
<pre><code>sudo brew install kubectl-cli

kubectl version --client
</code></pre><p>Â 
JÃ¡ com o mÃ©todo tradicional, a instalaÃ§Ã£o pode ser realizada com os seguintes comandos.</p>
<pre><code>curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/amd64/kubectl&quot;

sudo mv ./kubectl /usr/local/bin/kubectl

sudo chown root: /usr/local/bin/kubectl

kubectl version --client
</code></pre><p>Â </p>
<h4 id="instalaÃ§Ã£o-do-kubectl-no-windows">InstalaÃ§Ã£o do Kubectl no Windows</h4>
<p>A instalaÃ§Ã£o do <code>kubectl</code> pode ser realizada efetuando o download <a href="https://dl.k8s.io/release/v1.29.1/bin/windows/amd64/kubectl.exe" target="_blank">neste link</a>. </p>
<p>Outras informaÃ§Ãµes sobre como instalar o kubectl no Windows podem ser encontradas <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/" target="_blank">nesta pÃ¡gina</a>.</p>
<h3 id="customizando-o-kubectl">Customizando o kubectl</h3>
<h4 id="auto-complete">Auto-complete</h4>
<p>Execute o seguinte comando para configurar o alias e autocomplete para o <code>kubectl</code>.</p>
<p>No Bash:</p>
<pre><code class="lang-bash"><span class="hljs-built_in">source</span> &lt;(kubectl completion bash) <span class="hljs-comment"># configura o autocomplete na sua sessÃ£o atual (antes, certifique-se de ter instalado o pacote bash-completion).</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;source &lt;(kubectl completion bash)&quot;</span> &gt;&gt; ~/.bashrc <span class="hljs-comment"># add autocomplete permanentemente ao seu shell.</span>
</code></pre>
<p>Â 
No ZSH:</p>
<pre><code class="lang-bash"><span class="hljs-built_in">source</span> &lt;(kubectl completion zsh)

<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[[ <span class="hljs-variable">$commands</span>[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&quot;</span>
</code></pre>
<p>Â </p>
<h4 id="criando-um-alias-para-o-kubectl">Criando um alias para o kubectl</h4>
<p>Crie o alias <code>k</code> para <code>kubectl</code>:</p>
<pre><code>alias k=kubectl

complete -F __start_kubectl k
</code></pre><p>Â </p>
<h3 id="criando-um-cluster-kubernetes">Criando um cluster Kubernetes</h3>
<h3 id="criando-o-cluster-em-sua-mÃ¡quina-local">Criando o cluster em sua mÃ¡quina local</h3>
<p>Vamos mostrar algumas opÃ§Ãµes, caso vocÃª queira comeÃ§ar a brincar com o Kubernetes utilizando somente a sua mÃ¡quina local, o seu desktop.</p>
<p>Lembre-se, vocÃª nÃ£o Ã© obrigado a testar/utilizar todas as opÃ§Ãµes abaixo, mas seria muito bom caso vocÃª testasse. :D</p>
<h4 id="minikube">Minikube</h4>
<h5 id="requisitos-bÃ¡sicos">Requisitos bÃ¡sicos</h5>
<p>Ã‰ importante frisar que o Minikube deve ser instalado localmente, e nÃ£o em um <em>cloud provider</em>. Por isso, as especificaÃ§Ãµes de <em>hardware</em> a seguir sÃ£o referentes Ã  mÃ¡quina local.</p>
<ul>
<li>Processamento: 2 CPUs;</li>
<li>MemÃ³ria: 2 GB;</li>
<li>HD: 20 GB.</li>
</ul>
<h5 id="instalaÃ§Ã£o-do-minikube-no-gnulinux">InstalaÃ§Ã£o do Minikube no GNU/Linux</h5>
<p>Antes de mais nada, verifique se a sua mÃ¡quina suporta virtualizaÃ§Ã£o. No GNU/Linux, isto pode ser realizado com o seguinte comando:</p>
<pre><code>grep -E --color &apos;vmx|svm&apos; /proc/cpuinfo
</code></pre><p>Â 
Caso a saÃ­da do comando nÃ£o seja vazia, o resultado Ã© positivo.</p>
<p>HÃ¡ a possibilidade de nÃ£o utilizar um <em>hypervisor</em> para a instalaÃ§Ã£o do Minikube, executando-o ao invÃ©s disso sobre o prÃ³prio host. Iremos utilizar o Oracle VirtualBox como <em>hypervisor</em>, que pode ser encontrado <a href="https://www.virtualbox.org" target="_blank">aqui</a>.</p>
<p>Efetue o download e a instalaÃ§Ã£o do <code>Minikube</code> utilizando os seguintes comandos.</p>
<pre><code>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64

chmod +x ./minikube

sudo mv ./minikube /usr/local/bin/minikube

minikube version
</code></pre><p>Â </p>
<h5 id="instalaÃ§Ã£o-do-minikube-no-macos">InstalaÃ§Ã£o do Minikube no MacOS</h5>
<p>No MacOS, o comando para verificar se o processador suporta virtualizaÃ§Ã£o Ã©:</p>
<pre><code>sysctl -a | grep -E --color &apos;machdep.cpu.features|VMX&apos;
</code></pre><p>Â 
Se vocÃª visualizar <code>VMX</code> na saÃ­da, o resultado Ã© positivo.</p>
<p>Efetue a instalaÃ§Ã£o do Minikube com um dos dois mÃ©todos a seguir, podendo optar-se pelo Homebrew ou pelo mÃ©todo tradicional.</p>
<pre><code>sudo brew install minikube

minikube version
</code></pre><p>Â 
Ou:</p>
<pre><code>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64

chmod +x ./minikube

sudo mv ./minikube /usr/local/bin/minikube

minikube version
</code></pre><p>Â </p>
<h5 id="instalaÃ§Ã£o-do-minikube-no-microsoft-windows">InstalaÃ§Ã£o do Minikube no Microsoft Windows</h5>
<p>No Microsoft Windows, vocÃª deve executar o comando <code>systeminfo</code> no prompt de comando ou no terminal. Caso o retorno deste comando seja semelhante com o descrito a seguir, entÃ£o a virtualizaÃ§Ã£o Ã© suportada.</p>
<pre><code>Hyper-V Requirements:     VM Monitor Mode Extensions: Yes
                          Virtualization Enabled In Firmware: Yes
                          Second Level Address Translation: Yes
                          Data Execution Prevention Available: Yes
</code></pre><p>Â 
Caso a linha a seguir tambÃ©m esteja presente, nÃ£o Ã© necessÃ¡ria a instalaÃ§Ã£o de um <em>hypervisor</em> como o Oracle VirtualBox:</p>
<pre><code>Hyper-V Requirements:     A hypervisor has been detected. Features required for Hyper-V will not be displayed.:     A hypervisor has been detected. Features required for Hyper-V will not be displayed.
</code></pre><p>Â 
FaÃ§a o download e a instalaÃ§Ã£o de um <em>hypervisor</em> (preferencialmente o <a href="https://www.virtualbox.org" target="_blank">Oracle VirtualBox</a>), caso no passo anterior nÃ£o tenha sido acusada a presenÃ§a de um. Finalmente, efetue o download do instalador do Minikube <a href="https://github.com/kubernetes/minikube/releases/latest/download/minikube-windows-amd64.exe" target="_blank">aqui</a> e execute-o.</p>
<h5 id="iniciando-parando-e-excluindo-o-minikube">Iniciando, parando e excluindo o Minikube</h5>
<p>Quando operando em conjunto com um <em>hypervisor</em>, o Minikube cria uma mÃ¡quina virtual, onde dentro dela estarÃ£o todos os componentes do k8s para execuÃ§Ã£o.</p>
<p>Ã‰ possÃ­vel selecionar qual <em>hypervisor</em> iremos utilizar por padrÃ£o, atravÃ©s no comando abaixo:</p>
<pre><code>minikube config set driver &lt;SEU_HYPERVISOR&gt;
</code></pre><p>Â 
VocÃª deve substituir <seu_hypervisor> pelo seu hypervisor, por exemplo o KVM2, QEMU, Virtualbox ou o Hyperkit.</seu_hypervisor></p>
<p>Caso nÃ£o queria configurar um hypervisor padrÃ£o, vocÃª pode digitar o comando <code>minikube start --driver=hyperkit</code> toda vez que criar um novo ambiente. </p>
<h5 id="certo-e-como-eu-sei-que-estÃ¡-tudo-funcionando-como-deveria">Certo, e como eu sei que estÃ¡ tudo funcionando como deveria?</h5>
<p>Uma vez iniciado, vocÃª deve ter uma saÃ­da na tela similar Ã  seguinte:</p>
<pre><code>minikube start

ğŸ˜„  minikube v1.26.0 on Debian bookworm/sid
âœ¨  Using the qemu2 (experimental) driver based on user configuration
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸ”¥  Creating qemu2 VM (CPUs=2, Memory=6000MB, Disk=20000MB) ...
ğŸ³  Preparing Kubernetes v1.24.1 on Docker 20.10.16 ...
    â–ª Generating certificates and keys ...
    â–ª Booting up control plane ...
    â–ª Configuring RBAC rules ...
ğŸ”  Verifying Kubernetes components...
    â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: default-storageclass, storage-provisioner
ğŸ„  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default
</code></pre><p>VocÃª pode entÃ£o listar os nÃ³s que fazem parte do seu <em>cluster</em> k8s com o seguinte comando:</p>
<pre><code>kubectl get nodes
</code></pre><p>Â 
A saÃ­da serÃ¡ similar ao conteÃºdo a seguir:</p>
<pre><code>NAME       STATUS   ROLES           AGE   VERSION
minikube   Ready    control-plane   20s   v1.25.3
</code></pre><p>Â 
Para criar um cluster com mais de um nÃ³, vocÃª pode utilizar o comando abaixo, apenas modificando os valores para o desejado:</p>
<pre><code>minikube start --nodes 2 -p multinode-cluster

ğŸ˜„  minikube v1.26.0 on Debian bookworm/sid
âœ¨  Automatically selected the docker driver. Other choices: kvm2, virtualbox, ssh, none, qemu2 (experimental)
ğŸ“Œ  Using Docker driver with root privileges
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸšœ  Pulling base image ...
ğŸ’¾  Downloading Kubernetes v1.24.1 preload ...
    &gt; preloaded-images-k8s-v18-v1...: 405.83 MiB / 405.83 MiB  100.00% 66.78 Mi
    &gt; gcr.io/k8s-minikube/kicbase: 385.99 MiB / 386.00 MiB  100.00% 23.63 MiB p
    &gt; gcr.io/k8s-minikube/kicbase: 0 B [_________________________] ?% ? p/s 11s
ğŸ”¥  Creating docker container (CPUs=2, Memory=8000MB) ...
ğŸ³  Preparing Kubernetes v1.24.1 on Docker 20.10.17 ...
    â–ª Generating certificates and keys ...
    â–ª Booting up control plane ...
    â–ª Configuring RBAC rules ...
ğŸ”—  Configuring CNI (Container Networking Interface) ...
ğŸ”  Verifying Kubernetes components...
    â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass

ğŸ‘  Starting worker node minikube-m02 in cluster minikube
ğŸšœ  Pulling base image ...
ğŸ”¥  Creating docker container (CPUs=2, Memory=8000MB) ...
ğŸŒ  Found network options:
    â–ª NO_PROXY=192.168.11.11
ğŸ³  Preparing Kubernetes v1.24.1 on Docker 20.10.17 ...
    â–ª env NO_PROXY=192.168.11.11
ğŸ”  Verifying Kubernetes components...
ğŸ„  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default
</code></pre><p>Â 
Para visualizar os nÃ³s do seu novo cluster Kubernetes, digite:</p>
<pre><code>kubectl get nodes
</code></pre><p>Â 
Inicialmente, a intenÃ§Ã£o do Minikube Ã© executar o k8s em apenas um nÃ³, porÃ©m a partir da versÃ£o 1.10.1 Ã© possÃ­vel usar a funÃ§Ã£o de multi-node.</p>
<p>Caso os comandos anteriores tenham sido executados sem erro, a instalaÃ§Ã£o do Minikube terÃ¡ sido realizada com sucesso.</p>
<h5 id="ver-detalhes-sobre-o-cluster">Ver detalhes sobre o cluster</h5>
<pre><code>minikube status
</code></pre><p>Â </p>
<h5 id="descobrindo-o-endereÃ§o-do-minikube">Descobrindo o endereÃ§o do Minikube</h5>
<p>Como dito anteriormente, o Minikube irÃ¡ criar uma mÃ¡quina virtual, assim como o ambiente para a execuÃ§Ã£o do k8s localmente. Ele tambÃ©m irÃ¡ configurar o <code>kubectl</code> para comunicar-se com o Minikube. Para saber qual Ã© o endereÃ§o IP dessa mÃ¡quina virtual, pode-se executar:</p>
<pre><code>minikube ip
</code></pre><p>Â 
O endereÃ§o apresentado Ã© que deve ser utilizado para comunicaÃ§Ã£o com o k8s.</p>
<h5 id="acessando-a-mÃ¡quina-do-minikube-via-ssh">Acessando a mÃ¡quina do Minikube via SSH</h5>
<p>Para acessar a mÃ¡quina virtual criada pelo Minikube, pode-se executar:</p>
<pre><code>minikube ssh
</code></pre><p>Â </p>
<h5 id="dashboard-do-minikube">Dashboard do Minikube</h5>
<p>O Minikube vem com um <em>dashboard</em> <em>web</em> interessante para que o usuÃ¡rio iniciante observe como funcionam os <em>workloads</em> sobre o k8s. Para habilitÃ¡-lo, o usuÃ¡rio pode digitar:</p>
<pre><code>minikube dashboard
</code></pre><p>Â </p>
<h5 id="logs-do-minikube">Logs do Minikube</h5>
<p>Os <em>logs</em> do Minikube podem ser acessados atravÃ©s do seguinte comando.</p>
<pre><code>minikube logs
</code></pre><p>Â </p>
<h5 id="remover-o-cluster">Remover o cluster</h5>
<pre><code>minikube delete
</code></pre><p>Â 
Caso queira remover o cluster e todos os arquivos referente a ele, utilize o parametro <em>--purge</em>, conforme abaixo:</p>
<pre><code>minikube delete --purge
</code></pre><p>Â </p>
<h4 id="kind">Kind</h4>
<p>O Kind (<em>Kubernetes in Docker</em>) Ã© outra alternativa para executar o Kubernetes num ambiente local para testes e aprendizado, mas nÃ£o Ã© recomendado para uso em produÃ§Ã£o.</p>
<h5 id="instalaÃ§Ã£o-no-gnulinux">InstalaÃ§Ã£o no GNU/Linux</h5>
<p>Para fazer a instalaÃ§Ã£o no GNU/Linux, execute os seguintes comandos.</p>
<pre><code>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64

chmod +x ./kind

sudo mv ./kind /usr/local/bin/kind
</code></pre><p>Â </p>
<h5 id="instalaÃ§Ã£o-no-macos">InstalaÃ§Ã£o no MacOS</h5>
<p>Para fazer a instalaÃ§Ã£o no MacOS, execute o seguinte comando.</p>
<pre><code>sudo brew install kind
</code></pre><p>Â 
ou</p>
<pre><code>curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-darwin-amd64
chmod +x ./kind
mv ./kind /usr/bin/kind
</code></pre><p>Â </p>
<h5 id="instalaÃ§Ã£o-no-windows">InstalaÃ§Ã£o no Windows</h5>
<p>Para fazer a instalaÃ§Ã£o no Windows, execute os seguintes comandos.</p>
<pre><code>curl.exe -Lo kind-windows-amd64.exe https://kind.sigs.k8s.io/dl/v0.20.0/kind-windows-amd64
Move-Item .\kind-windows-amd64.exe c:\kind.exe
</code></pre><p>Â </p>
<h6 id="instalaÃ§Ã£o-no-windows-via-chocolatey">InstalaÃ§Ã£o no Windows via Chocolatey</h6>
<p>Execute o seguinte comando para instalar o Kind no Windows usando o Chocolatey.</p>
<pre><code>choco install kind
</code></pre><p>Â </p>
<h5 id="criando-um-cluster-com-o-kind">Criando um cluster com o Kind</h5>
<p>ApÃ³s realizar a instalaÃ§Ã£o do Kind, vamos iniciar o nosso cluster.</p>
<pre><code>kind create cluster

Creating cluster &quot;kind&quot; ...
 âœ“ Ensuring node image (kindest/node:v1.24.0) ğŸ–¼
 âœ“ Preparing nodes ğŸ“¦  
 âœ“ Writing configuration ğŸ“œ 
 âœ“ Starting control-plane ğŸ•¹ï¸ 
 âœ“ Installing CNI ğŸ”Œ 
 âœ“ Installing StorageClass ğŸ’¾ 
Set kubectl context to &quot;kind-kind&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-kind

Not sure what to do next? ğŸ˜…  Check out https://kind.sigs.k8s.io/docs/user/quick-start/
</code></pre><p>Â 
Ã‰ possÃ­vel criar mais de um cluster e personalizar o seu nome.</p>
<pre><code>kind create cluster --name giropops

Creating cluster &quot;giropops&quot; ...
 âœ“ Ensuring node image (kindest/node:v1.24.0) ğŸ–¼
 âœ“ Preparing nodes ğŸ“¦  
 âœ“ Writing configuration ğŸ“œ 
 âœ“ Starting control-plane ğŸ•¹ï¸ 
 âœ“ Installing CNI ğŸ”Œ 
 âœ“ Installing StorageClass ğŸ’¾ 
Set kubectl context to &quot;kind-giropops&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-giropops

Thanks for using kind! ğŸ˜Š
</code></pre><p>Â 
Para visualizar os seus clusters utilizando o kind, execute o comando a seguir.</p>
<pre><code>kind get clusters
</code></pre><p>Â 
Liste os nodes do cluster.</p>
<pre><code>kubectl get nodes
</code></pre><p>Â </p>
<h5 id="criando-um-cluster-com-mÃºltiplos-nÃ³s-locais-com-o-kind">Criando um cluster com mÃºltiplos nÃ³s locais com o Kind</h5>
<p>Ã‰ possÃ­vel para essa aula incluir mÃºltiplos nÃ³s na estrutura do Kind, que foi mencionado anteriormente.</p>
<p>Execute o comando a seguir para selecionar e remover todos os clusters locais criados no Kind.</p>
<pre><code>kind delete clusters $(kind get clusters)

Deleted clusters: [&quot;giropops&quot; &quot;kind&quot;]
</code></pre><p>Â 
Crie um arquivo de configuraÃ§Ã£o para definir quantos e quais os tipos de nÃ³s que vocÃª deseja criar no cluster. No exemplo a seguir, serÃ¡ criado o arquivo de configuraÃ§Ã£o <code>kind-3nodes.yaml</code> para especificar um cluster com 1 nÃ³ control-plane (que executarÃ¡ o control plane) e 2 workers.</p>
<pre><code>cat &lt;&lt; EOF &gt; $HOME/kind-3nodes.yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
  - role: control-plane
  - role: worker
  - role: worker
EOF
</code></pre><p>Â 
Agora vamos criar um cluster chamado <code>kind-multinodes</code> utilizando as especificaÃ§Ãµes definidas no arquivo <code>kind-3nodes.yaml</code>.</p>
<pre><code>kind create cluster --name kind-multinodes --config $HOME/kind-3nodes.yaml

Creating cluster &quot;kind-multinodes&quot; ...
 âœ“ Ensuring node image (kindest/node:v1.24.0) ğŸ–¼
 âœ“ Preparing nodes ğŸ“¦ ğŸ“¦ ğŸ“¦  
 âœ“ Writing configuration ğŸ“œ 
 âœ“ Starting control-plane ğŸ•¹ï¸ 
 âœ“ Installing CNI ğŸ”Œ 
 âœ“ Installing StorageClass ğŸ’¾ 
 âœ“ Joining worker nodes ğŸšœ 
Set kubectl context to &quot;kind-kind-multinodes&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-kind-multinodes

Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community ğŸ™‚
</code></pre><p>Â 
Valide a criaÃ§Ã£o do cluster com o comando a seguir.</p>
<pre><code>kubectl get nodes
</code></pre><p>Â 
Mais informaÃ§Ãµes sobre o Kind estÃ£o disponÃ­veis em: <a href="https://kind.sigs.k8s.io" target="_blank">https://kind.sigs.k8s.io</a></p>
<p>Â </p>
<h3 id="primeiros-passos-no-k8s">Primeiros passos no k8s</h3>
<p>Â </p>
<h5 id="verificando-os-namespaces-e-pods">Verificando os namespaces e pods</h5>
<p>O k8s organiza tudo dentro de <em>namespaces</em>. Por meio deles, podem ser realizadas limitaÃ§Ãµes de seguranÃ§a e de recursos dentro do <em>cluster</em>, tais como <em>pods</em>, <em>replication controllers</em> e diversos outros. Para visualizar os <em>namespaces</em> disponÃ­veis no <em>cluster</em>, digite:</p>
<pre><code>kubectl get namespaces
</code></pre><p>Â 
Vamos listar os <em>pods</em> do <em>namespace</em> <strong>kube-system</strong> utilizando o comando a seguir.</p>
<pre><code>kubectl get pod -n kube-system
</code></pre><p>Â 
SerÃ¡ que hÃ¡ algum <em>pod</em> escondido em algum <em>namespace</em>? Ã‰ possÃ­vel listar todos os <em>pods</em> de todos os <em>namespaces</em> com o comando a seguir.</p>
<pre><code>kubectl get pods -A
</code></pre><p>Â 
HÃ¡ a possibilidade ainda, de utilizar o comando com a opÃ§Ã£o <code>-o wide</code>, que disponibiliza maiores informaÃ§Ãµes sobre o recurso, inclusive em qual nÃ³ o <em>pod</em> estÃ¡ sendo executado. Exemplo:</p>
<pre><code>kubectl get pods -A -o wide
</code></pre><p>Â </p>
<h5 id="executando-nosso-primeiro-pod-no-k8s">Executando nosso primeiro pod no k8s</h5>
<p>Iremos iniciar o nosso primeiro <em>pod</em> no k8s. Para isso, executaremos o comando a seguir.</p>
<pre><code>kubectl run nginx --image nginx

pod/nginx created
</code></pre><p>Â 
Listando os <em>pods</em> com <code>kubectl get pods</code>, obteremos a seguinte saÃ­da.</p>
<pre><code>NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          66s
</code></pre><p>Â 
Vamos agora remover o nosso <em>pod</em> com o seguinte comando.</p>
<pre><code>kubectl delete pod nginx
</code></pre><p>Â 
A saÃ­da deve ser algo como:</p>
<pre><code>pod &quot;nginx&quot; deleted
</code></pre><p>Â </p>
<h5 id="executando-nosso-primeiro-pod-no-k8s-utilizando-um-arquivo-manifesto">Executando nosso primeiro pod no k8s utilizando um arquivo manifesto</h5>
<p>Uma outra forma de criar um pod ou qualquer outro objeto no Kubernetes Ã© atravÃ©s da utilizaÃ§Ã¢o de uma arquivo manifesto, que Ã© uma arquivo em formato YAML onde vocÃª passa todas as definiÃ§Ãµes do seu objeto. Mas pra frente vamos falar mais sobre como construir arquivos manifesto, mas agora eu quero que vocÃª conheÃ§a a opÃ§Ã£o <code>--dry-run</code> do <code>kubectl</code>, com ela podemos simular a criaÃ§Ã£o de um resource e ainda ter um manifesto criado automaticamente. </p>
<p>Para a criaÃ§Ã£o do template de um <em>pod</em>:</p>
<pre><code>kubectl run meu-nginx --image nginx --dry-run=client -o yaml &gt; pod-template.yaml
</code></pre><p>Â 
Estamos utilizando o parametro &apos;-o&apos; para modificar a saÃ­da para o formato YAML e redirecionando a saÃ­da para um arquivo chamado &apos;pod-template.yaml&apos;.</p>
<p>Para a criaÃ§Ã£o do <em>template</em> de um <em>deployment</em>:</p>
<p>Com o arquivo gerado em mÃ£os, agora vocÃª consegue criar um pod utilizando o manifesto que criamos da seguinte forma:</p>
<pre><code>kubectl apply -f pod-template.yaml
</code></pre><p>NÃ£o se preocupe por enquanto com o parametro &apos;apply&apos;, nÃ³s ainda vamos falar com mais detalhes sobre ele, nesse momento o importante Ã© vocÃª saber que ele Ã© utilizado para criar novos resources atravÃ©s de arquivos manifestos.</p>
<p>Â </p>
<h4 id="expondo-o-pod-e-criando-um-service">Expondo o pod e criando um Service</h4>
<p>Dispositivos fora do <em>cluster</em>, por padrÃ£o, nÃ£o conseguem acessar os <em>pods</em> criados, como Ã© comum em outros sistemas de contÃªineres. Para expor um <em>pod</em>, execute o comando a seguir.</p>
<pre><code>kubectl expose pod nginx
</code></pre><p>SerÃ¡ apresentada a seguinte mensagem de erro:</p>
<pre><code>error: couldn&apos;t find port via --port flag or introspection
See &apos;kubectl expose -h&apos; for help and examples
</code></pre><p>O erro ocorre devido ao fato do k8s nÃ£o saber qual Ã© a porta de destino do contÃªiner que deve ser exposta (no caso, a 80/TCP). Para configurÃ¡-la, vamos primeiramente remover o nosso <em>pod</em> antigo:</p>
<pre><code>kubectl delete -f pod-template.yaml
</code></pre><p>Agora vamos executar novamente o comando para a criaÃ§Ã£o do pod utilizando o parametro &apos;dry-run&apos;, adicionando o parametro &apos;--port&apos; para dizer qual a porta que o container estÃ¡ escutando, lembrando que estamos utilizando o nginx nesse exemplo, um webserver que escuta por padrÃ£o na porta 80.</p>
<pre><code>kubectl run meu-nginx --image nginx --port 80 --dry-run=client -o yaml &gt; pod-template.yaml
kubectl create -f pod-template.yaml
</code></pre><p>Liste os pods.</p>
<pre><code>kubectl get pods

NAME    READY   STATUS    RESTARTS   AGE
meu-nginx   1/1     Running   0          32s
</code></pre><p>O comando a seguir cria um objeto do k8s chamado de <em>Service</em>, que Ã© utilizado justamente para expor <em>pods</em> para acesso externo.</p>
<pre><code>kubectl expose pod meu-nginx
</code></pre><p>Podemos listar todos os <em>services</em> com o comando a seguir.</p>
<pre><code>kubectl get services

NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   8d
nginx        ClusterIP   10.105.41.192   &lt;none&gt;        80/TCP    2m30s
</code></pre><p>Como Ã© possÃ­vel observar, hÃ¡ dois <em>services</em> no nosso <em>cluster</em>: o primeiro Ã© para uso do prÃ³prio k8s, enquanto o segundo foi o quÃª acabamos de criar. </p>
<p>Â </p>
<h4 id="limpando-tudo-e-indo-para-casa">Limpando tudo e indo para casa</h4>
<p>Para mostrar todos os recursos recÃ©m criados, pode-se utilizar uma das seguintes opÃ§Ãµes a seguir.</p>
<pre><code>kubectl get all

kubectl get pod,service

kubectl get pod,svc
</code></pre><p>Note que o k8s nos disponibiliza algumas abreviaÃ§Ãµes de seus recursos. Com o tempo vocÃª irÃ¡ se familiar com elas. Para apagar os recursos criados, vocÃª pode executar os seguintes comandos.</p>
<pre><code>kubectl delete -f pod-template.yaml
kubectl delete service nginx
</code></pre><p>Liste novamente os recursos para verificar se eles foram removidos.</p>
<p>Â </p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../" class="navigation navigation-prev " aria-label="Previous page: IntroduÃ§Ã£o">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../day-2/" class="navigation navigation-next " aria-label="Next page: Descomplicando Kubernetes dia 2">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Descomplicando Kubernetes dia 1","level":"2.1","depth":1,"next":{"title":"Descomplicando Kubernetes dia 2","level":"2.2","depth":1,"path":"day-2/README.md","ref":"day-2/README.md","articles":[]},"previous":{"title":"IntroduÃ§Ã£o","level":"1.1","depth":1,"path":"README.md","ref":"README.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"pt","gitbook":"*"},"file":{"path":"day-1/README.md","mtime":"2024-01-31T14:02:02.715Z","type":"markdown"},"gitbook":{"version":"3.6.20","time":"2024-01-31T14:02:13.258Z"},"basePath":"..","book":{"language":"pt"}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

