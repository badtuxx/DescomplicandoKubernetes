
<!DOCTYPE HTML>
<html lang="pt" >
    <head>
        <meta charset="UTF-8">
        <title>Descomplicando Kubernetes dia 4 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.6.20">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../day-5/" />
    
    
    <link rel="prev" href="../day-3/" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escreva para pesquisar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Sobre</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introdução
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Capítulos</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../day-1/">
            
                <a href="../day-1/">
            
                    
                    Descomplicando Kubernetes dia 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../day-2/">
            
                <a href="../day-2/">
            
                    
                    Descomplicando Kubernetes dia 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../day-3/">
            
                <a href="../day-3/">
            
                    
                    Descomplicando Kubernetes dia 3
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.4" data-path="./">
            
                <a href="./">
            
                    
                    Descomplicando Kubernetes dia 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../day-5/">
            
                <a href="../day-5/">
            
                    
                    Descomplicando Kubernetes dia 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="../day-6/">
            
                <a href="../day-6/">
            
                    
                    Descomplicando Kubernetes dia 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="../day-7/">
            
                <a href="../day-7/">
            
                    
                    Descomplicando Kubernetes dia 7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.8" data-path="../day-8/">
            
                <a href="../day-8/">
            
                    
                    Descomplicando Kubernetes dia 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.9" data-path="../day-9/">
            
                <a href="../day-9/">
            
                    
                    Descomplicando Kubernetes dia 9
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.10" data-path="../day-10/">
            
                <a href="../day-10/">
            
                    
                    Descomplicando Kubernetes dia 10
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.11" data-path="../day-11/">
            
                <a href="../day-11/">
            
                    
                    Descomplicando Kubernetes dia 11
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.12" data-path="../day-12/">
            
                <a href="../day-12/">
            
                    
                    Descomplicando Kubernetes dia 12
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.13" data-path="../day-13/">
            
                <a href="../day-13/">
            
                    
                    Descomplicando Kubernetes dia 13
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.14" data-path="../day-14/">
            
                <a href="../day-14/">
            
                    
                    Descomplicando Kubernetes dia 14
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.15" data-path="../day-15/README.md">
            
                <span>
            
                    
                    Descomplicando Kubernetes dia 15
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Contribuir</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../CONTRIBUTING.html">
            
                <a href="../CONTRIBUTING.html">
            
                    
                    Como ajudar
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Publicado com HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Descomplicando Kubernetes dia 4</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="descomplicando-o-kubernetes">Descomplicando o Kubernetes</h1>
<h2 id="day-4">DAY-4</h2>
<p> </p>
<p> </p>
<h2 id="conteúdo-do-day-4">Conteúdo do Day-4</h2>
<ul>
<li><a href="./">DAY-4</a></li>
<li><a href="#inicio-da-aula-do-day-4">Inicio da aula do Day-4</a><ul>
<li><a href="#o-que-iremos-ver-hoje">O que iremos ver hoje?</a></li>
<li><a href="#replicaset">ReplicaSet</a><ul>
<li><a href="#o-deployment-e-o-replicaset">O Deployment e o ReplicaSet</a></li>
<li><a href="#criando-um-replicaset">Criando um ReplicaSet</a></li>
<li><a href="#apagando-o-replicaset">Apagando o ReplicaSet</a></li>
</ul>
</li>
<li><a href="#o-daemonset">O DaemonSet</a><ul>
<li><a href="#criando-um-daemonset">Criando um DaemonSet</a></li>
<li><a href="#criando-um-daemonset-utilizando-o-comando-kubectl-create">Criando um DaemonSet utilizando o comando kubectl create</a></li>
<li><a href="#aumentando-um-node-no-cluster">Aumentando um node no cluster</a></li>
<li><a href="#removendo-um-daemonset">Removendo um DaemonSet</a></li>
</ul>
</li>
<li><a href="#as-probes-do-kubernetes">As Probes do Kubernetes</a><ul>
<li><a href="#o-que-sao-as-probes">O que são as Probes?</a></li>
<li><a href="#liveness-probe">Liveness Probe</a></li>
<li><a href="#readiness-probe">Readiness Probe</a></li>
<li><a href="#startup-probe">Startup Probe</a></li>
</ul>
</li>
<li><a href="#a-sua-licao-de-casa">A sua lição de casa</a></li>
<li><a href="#final-do-day-4">Final do Day-4</a></li>
</ul>
</li>
</ul>
<p> </p>
<h2 id="inicio-da-aula-do-day-4">Inicio da aula do Day-4</h2>
<h3 id="o-que-iremos-ver-hoje">O que iremos ver hoje?</h3>
<p>Hoje é dia de falar sobre dois objetos muito importantes no Kubernetes, os <code>ReplicaSets</code> e os <code>DaemonSets</code>.</p>
<p>Nós já sabemos o que é um <code>Deployment</code> e também já sabemos o que é um <code>Pod</code> no detalhe, então agora vamos conhecer essas duas figuras que estão super conectadas com o <code>Deployment</code> e com o <code>Pod</code>.
Quando falamos sobre <code>Deployment</code> é impossível não falar sobre <code>ReplicaSet</code>, pois o <code>Deployment</code> é um objeto que cria um <code>ReplicaSet</code> e o <code>ReplicaSet</code> é um objeto que cria um <code>Pod</code>, veja que tudo está conectado.</p>
<p>Já o nosso querido <code>DaemonSet</code> é um objeto que cria um <code>Pod</code> e esse <code>Pod</code> é um objeto que fica rodando em todos os nodes do cluster, super importante para nós, pois é com <code>DaemonSet</code> que nós conseguimos garantir que teremos pelo menos um <code>Pod</code> rodando em cada node do cluster. Por exemplo, imagine que você precisa de instalar os agente do <code>Datadog</code> ou ainda um <code>exporter</code> do <code>Prometheus</code> em todos os nodes do cluster, para isso você precisa de um <code>DaemonSet</code>.</p>
<p>Ainda no dia de hoje, nós iremos aprender como garantir que os nossos <code>Pods</code> estão rodando corretamente, através das <code>Probes</code> do Kubernetes.</p>
<p>Nós vamos falar sobre <code>Readiness Probe</code>, <code>Liveness Probe</code> e <code>Startup Probe</code>, e claro, mostrando todos os detalhes em exemplos práticos e super explicativos.</p>
<p>Hoje é o dia de você aprender sobre esses dois objetos que são super importantes, e ainda, garantir que nós nunca colocaremos os nossos <code>Pods</code> em produção sem antes garantir que eles estão rodando corretamente e sendo checados pelas <code>Probes</code> do Kubernetes.</p>
<p>Bora lá! #VAIIII</p>
<h3 id="replicaset">ReplicaSet</h3>
<p>Uma coisa é super importante de saber, quando estamos criando um <code>Deployment</code> no Kubernetes, automaticamente estamos criando além do <code>Deployment</code> um <code>ReplicaSet</code> e esse <code>ReplicaSet</code> é quem vai criar os <code>Pods</code> que estão dentro do <code>Deployment</code>.</p>
<p>Confuso, não?</p>
<p>Não, não é e vou te explicar.</p>
<p>Quando criamos um <code>Deployment</code>, o Kubernetes cria um <code>ReplicaSet</code> para criar e fazer o gerenciamento das réplicas dos <code>Pods</code> em nosso cluster. Ele é o responsável por ficar observando os <code>Pods</code> e garantir o número de réplicas que nós definimos no <code>Deployment</code>.</p>
<p>É possível criar um <code>ReplicaSet</code> sem um <code>Deployment</code>, mas não é uma boa prática, pois o <code>ReplicaSet</code> não tem a capacidade de fazer o gerenciamento de versões dos <code>Pods</code> e também não tem a capacidade de fazer o gerenciamento de <code>RollingUpdate</code> dos <code>Pods</code>.</p>
<p>E olha que interessante, quando estamos fazendo a atualização de uma versão de um <code>Pod</code> com o <code>Deployment</code>, o <code>Deployment</code> cria um novo <code>ReplicaSet</code> para fazer o gerenciamento das réplicas dos <code>Pods</code> e quando a atualização termina, o <code>Deployment</code> remove as réplicas do <code>ReplicaSet</code> antigo e deixa apenas as réplicas do <code>ReplicaSet</code> novo.</p>
<p>Mas ele não remove o <code>ReplicaSet</code> antigo, ele deixa ele lá, pois ele pode ser usado para fazer um <code>Rollback</code> da versão do <code>Pod</code> caso algo dê errado. Sim, quando precisamos fazer o <code>Rollback</code> de uma atualização em nossos <code>Pods</code>, o <code>Deployment</code> somente muda o <code>ReplicaSet</code> que está sendo usado para fazer o gerenciamento das réplicas dos <code>Pods</code>, passando a utilizar o <code>ReplicaSet</code> antigo.</p>
<p>Vamos fazer isso na prática?</p>
<p>Acho que vai te ajudar a entender melhor.</p>
<h4 id="o-deployment-e-o-replicaset">O Deployment e o ReplicaSet</h4>
<p>Vamos criar um <code>Deployment</code> com o nome de <code>nginx-deployment</code> e vamos criar 3 réplicas do <code>Pod</code> do <code>nginx</code>.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
</code></pre>
<p> </p>
<p>Vamos visualizar o <code>Deployment</code> foi criado.</p>
<pre><code class="lang-bash">kubectl get deployments
</code></pre>
<p> </p>
<p>A nossa saída será parecida com essa.</p>
<pre><code class="lang-bash">NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   1/1     1            1           7s
</code></pre>
<p> </p>
<p>Simples, eu nós já sabiamos! Jeferson, eu quero saber sobre o <code>ReplicaSet</code>!</p>
<p>Calma, pois o nosso querido <code>Deployment</code> já criou o <code>ReplicaSet</code> para nós.</p>
<p>Vamos visualizar o <code>ReplicaSet</code> que foi criado.</p>
<pre><code class="lang-bash">kubectl get replicasets
</code></pre>
<p>A nossa saída será parecida com essa.</p>
<pre><code class="lang-bash">NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-6dd8d7cfbd   1         1         1       37s
</code></pre>
<p> </p>
<p>Um coisa importante de observar na saída acima é que o <code>ReplicaSet</code> tem o mesmo nome do <code>Deployment</code> seguido de um sufixo aleatório, e ainda nessa saída podemos saber que o <code>ReplicaSet</code> atualmente tem 1 réplica do <code>Pod</code> do <code>nginx</code> rodando, de acordo com o que nós definimos no <code>Deployment</code>.</p>
<p>Vamos aumentar o número de réplicas do <code>Pod</code> do <code>nginx</code> para 3.</p>
<pre><code class="lang-bash">kubectl scale deployment nginx-deployment --replicas=3
</code></pre>
<p> </p>
<p>Essa é uma forma de aumentar o número de réplicas do <code>Pod</code> do <code>nginx</code> sem precisar editar o <code>Deployment</code>, eu não recomendo, eu prefiro editar o <code>Deployment</code> e fazer o <code>apply</code> novamente, mas isso é uma questão de gosto e organização. Eu não gosto da ideia de ter que ficar fazendo <code>scale</code> no <code>Deployment</code> para aumentar ou diminuir o número de réplicas do <code>Pod</code> do <code>nginx</code>, sem ter isso registrado no <code>git</code>, por exemplo.</p>
<p>Alterando o <code>Deployment</code> para 3 réplicas.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
</code></pre>
<p> </p>
<p>Pronto, você conhece as duas opções de aumentar o número de réplicas do <code>Pod</code> do <code>nginx</code>, fique a vonta para escolher a que você achar melhor.</p>
<p>Eu vou continuar usando a opção de editar o <code>Deployment</code> e fazer o <code>apply</code> novamente.</p>
<pre><code class="lang-bash">kubectl apply -f nginx-deployment.yaml
</code></pre>
<p> </p>
<p>Vamos verificar o nosso <code>ReplicaSet</code> novamente.</p>
<pre><code class="lang-bash">kubectl get replicasets
</code></pre>
<p> </p>
<p>A nossa saída será parecida com essa.</p>
<pre><code class="lang-bash">NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-6dd8d7cfbd   3         3         3       5m24s
</code></pre>
<p> </p>
<p>Perceba que o nome do <code>ReplicaSet</code> continua o mesmo, mas o número de réplicas mudou para 3. Quando somente alteramos o número de réplicas do nosso <code>Deployment</code>, o <code>ReplicaSet</code> permanece o mesmo, afinal sua principal função é fazer o gerenciamento das réplicas do <code>Pod</code> do <code>nginx</code>.</p>
<p>Agora vamos mudar a versão do <code>nginx</code> para a versão 1.19.2.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.2</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
</code></pre>
<p> </p>
<p>Vamos aplicar as alterações.</p>
<pre><code class="lang-bash">kubectl apply -f nginx-deployment.yaml
</code></pre>
<p> </p>
<p>Pronto, agora o <code>Deployment</code> está usando a versão 1.19.2 do <code>nginx</code>.</p>
<p>Vamos verificar o nosso <code>ReplicaSet</code> novamente.</p>
<pre><code class="lang-bash">kubectl get replicasets
</code></pre>
<p> </p>
<p>Teremos agora a seguinte saída.</p>
<pre><code class="lang-bash">NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-6dd8d7cfbd   0         0         0       8m53s
nginx-deployment-7858bcf56f   1         1         1       13s
</code></pre>
<p> </p>
<p>Agora sim nós temos um novo <code>ReplicaSet</code> com o nome de <code>nginx-deployment-7858bcf56f</code>, e o <code>ReplicaSet</code> antigo com o nome de <code>nginx-deployment-6dd8d7cfbd</code> foi esvaziado, pois ele não faz mais parte do <code>Deployment</code>, mas permanece no cluster, pois ele pode ser usado para fazer o rollback para a versão anterior do <code>nginx</code>.</p>
<p>Vamos ver um detalhe interessante em nosso <code>Deployment</code>.</p>
<pre><code class="lang-bash">kubectl describe deployment nginx-deployment
</code></pre>
<p> </p>
<p>Olha a linha referente ao <code>ReplicaSet</code> que está sendo gerenciado pelo <code>Deployment</code>.</p>
<pre><code class="lang-bash">NewReplicaSet:   nginx-deployment-7858bcf56f (3/3 replicas created)
</code></pre>
<p> </p>
<p>Sim, na saída do <code>describe</code> nós podemos ver que o <code>Deployment</code> está gerenciando o <code>ReplicaSet</code> com o nome de <code>nginx-deployment-7858bcf56f</code> e que ele tem 3 réplicas do <code>Pod</code> do <code>nginx</code> rodando.</p>
<p>Se você quiser fazer o rollback para a versão anterior do <code>nginx</code>, basta fazer o seguinte, conforme nós já vimos anteriormente.</p>
<pre><code class="lang-bash">kubectl rollout undo deployment nginx-deployment
</code></pre>
<p> </p>
<p>Com isso será feito o rollback para a versão anterior do <code>nginx</code> e o <code>ReplicaSet</code> com o nome de <code>nginx-deployment-7858bcf56f</code> será esvaziado e o <code>ReplicaSet</code> com o nome de <code>nginx-deployment-6dd8d7cfbd</code> será preenchido novamente com 3 réplicas do <code>Pod</code> do <code>nginx</code>.</p>
<p>Vamos listar novamente os nossos <code>ReplicaSet</code>.</p>
<pre><code class="lang-bash">kubectl get replicasets
</code></pre>
<p> </p>
<p>O que temos agora é isso.</p>
<pre><code class="lang-bash">NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-6dd8d7cfbd   3         3         3       15m
nginx-deployment-7858bcf56f   0         0         0       6m28s
</code></pre>
<p> </p>
<p>E se olharmos o <code>Deployment</code> novamente.</p>
<pre><code class="lang-bash">kubectl describe deployment nginx-deployment
</code></pre>
<p> </p>
<p>Teremos a seguinte saída.</p>
<pre><code class="lang-bash">NewReplicaSet:   nginx-deployment-6dd8d7cfbd (3/3 replicas created)
</code></pre>
<p> </p>
<p>Simples demais, não é mesmo?</p>
<p>Então agora você já sabe como fazer o gerenciamento de réplicas do <code>Pod</code> do <code>nginx</code> usando o <code>Deployment</code>, e por consequência o <code>ReplicaSet</code>.</p>
<p> </p>
<h4 id="criando-um-replicaset">Criando um ReplicaSet</h4>
<p>Como foi falado anteriormente, é possível você criar um <code>ReplicaSet</code> sem ser através de um <code>Deployment</code>, apesar de insistir, não faça isso, pois o <code>Deployment</code> é a forma mais fácil de gerenciar os <code>ReplicaSet</code> e a saúde dos <code>Pods</code>.</p>
<p>Mas vamos lá, caso você queira criar um <code>ReplicaSet</code> sem ser através de um <code>Deployment</code>, basta fazer o seguinte.</p>
<p>Para o nosso exemplo, vamos criar um arquivo com o nome de <code>nginx-replicaset.yaml</code> e vamos colocar o seguinte conteúdo.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-replicaset</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.2</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
</code></pre>
<p> </p>
<p>Antes de aplicar o nosso manifesto, vamos entender o que estamos fazendo.
Se você observar o nosso arquivo, não tem nada de novo, ou seja, nada que você já não tenha aprendido até agora. A principal diferença é que agora nós estamos usando o <code>kind: ReplicaSet</code> e não o <code>kind: Deployment</code>, até o <code>APIVersion</code> é a mesmo.</p>
<p>Agora vamos aplicar o nosso manifesto.</p>
<pre><code class="lang-bash">kubectl apply -f nginx-replicaset.yaml
</code></pre>
<p> </p>
<p>A saída será essa.</p>
<pre><code class="lang-bash">NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-6dd8d7cfbd   3         3         3       21m
nginx-deployment-7858bcf56f   0         0         0       12m
nginx-replicaset              3         3         3       6s
</code></pre>
<p> </p>
<p>Agora nós temos 3 <code>ReplicaSet</code> sendo gerenciados pelo <code>Kubernetes</code>, sendo que 2 deles são gerenciados pelo <code>Deployment</code> e o outro foi o que acabamos de criar.</p>
<p>Vamos listar os <code>Pods</code> que estão rodando.</p>
<pre><code class="lang-bash">kubectl get pods
</code></pre>
<p> </p>
<p>Tudo rolando magicamente, certo?</p>
<p>Agora vamos fazer um teste, vamos alterar a versão do <code>nginx</code> para a versão 1.19.3, para isso vamos editar o nosso arquivo <code>nginx-replicaset.yaml</code> e vamos alterar a versão do <code>nginx</code> para a versão 1.19.3.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-replicaset</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.3</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
</code></pre>
<p> </p>
<p>Pronto, agora vamos aplicar as alterações.</p>
<pre><code class="lang-bash">kubectl apply -f nginx-replicaset.yaml
</code></pre>
<p> </p>
<p>Vamos listar os <code>Pods</code> novamente.</p>
<pre><code class="lang-bash">kubectl get pods
</code></pre>
<p> </p>
<p>Perceba que nada aconteceu, ou seja, o <code>ReplicaSet</code> não fez o rollout da nova versão do <code>nginx</code>, isso acontece porque o <code>ReplicaSet</code> não faz o gerenciamento de versões, ele apenas garante que o número de réplicas do <code>Pod</code> esteja sempre ativo.</p>
<p>Se você olhar os detalhes do <code>ReplicaSet</code> você vai ver que ele está gerenciando 3 réplicas do <code>Pod</code> e que a imagem do <code>nginx</code> é a versão 1.19.3, porém ele não recriou os <code>Pods</code> com a nova versão do <code>nginx</code>, ele somente irá fazer isso se você apagar os <code>Pods</code> manualmente ou se o <code>Pod</code> morrer por algum motivo.</p>
<pre><code class="lang-bash">kubectl describe replicaset nginx-replicaset
</code></pre>
<p> </p>
<p>Agora vamos apagar um dos <code>Pods</code> para que o <code>ReplicaSet</code> crie um novo <code>Pod</code> com a nova versão do <code>nginx</code>.</p>
<pre><code class="lang-bash">kubectl delete pod nginx-replicaset-8r6md
</code></pre>
<p> </p>
<p>Agora o <code>ReplicaSet</code> vai criar um novo <code>Pod</code> com a nova versão do <code>nginx</code>, e gerando um problema para nós, pois agora nós temos duas versões do <code>nginx</code> rodando no nosso cluster.</p>
<pre><code class="lang-bash">kubectl get pods -o=jsonpath=<span class="hljs-string">&apos;{range .items[*]}{&quot;\n&quot;}{.metadata.name}{&quot;\t&quot;}{range .spec.containers[*]}{.image}{&quot;\t&quot;}{end}{end}&apos;</span>
</code></pre>
<p> </p>
<p>Essa é uma forma de você listar os <code>Pods</code> e as imagens que estão sendo usadas por eles, eu sei que é bastante esquisito, mas vou explicar o que está acontecendo.</p>
<ul>
<li><p><code>kubectl get pods</code>: esse comando lista todos os Pods no cluster.</p>
</li>
<li><p><code>-o=jsonpath</code>: esse parâmetro especifica que queremos usar a saída em formato JSONPath para exibir as informações dos Pods.</p>
</li>
<li><p><code>&apos;{range .items[*]}{&quot;\n&quot;}{.metadata.name}{&quot;\t&quot;}{range .spec.containers[*]}{.image}{&quot;\t&quot;}{end}{end}&apos;</code>: essa é a expressão JSONPath que define o formato de saída do comando. Ela usa a função range para iterar sobre todos os objetos items (ou seja, os Pods) retornados pelo comando kubectl get pods. Em seguida, exibe o nome do Pod <code>({.metadata.name})</code> seguido de uma tabulação <code>(\t)</code>, e itera sobre todos os contêineres <code>({range .spec.containers[*]})</code> dentro do Pod, exibindo a imagem usada por cada um deles <code>({.image})</code>. Por fim, insere uma quebra de linha <code>(\n)</code> e fecha o segundo range com <code>{end}{end}</code>.</p>
</li>
</ul>
<p>Sim, eu sei, continua confuso!</p>
<p>Mas vou te contar um segredo, somente com o tempo e utilizando repetidas vezes, as coisas começam a ficar mais fáceis, então não desista! Pra trás, nem pra pegar impulso!</p>
<p>Ainda vamos falar com mais detalhes sobre como utilizar <code>metadata</code> para ter uma saída mais amigável e precisa.</p>
<h4 id="apagando-o-replicaset">Apagando o ReplicaSet</h4>
<p>Para remover o <code>ReplicaSet</code> e todos os <code>Pods</code> que ele está gerenciando, basta executar o comando abaixo.</p>
<pre><code class="lang-bash">kubectl delete replicaset nginx-replicaset
</code></pre>
<p> </p>
<p>Caso você queira fazer isso utilizando o arquivo de manifesto, basta executar o comando abaixo.</p>
<pre><code class="lang-bash">kubectl delete -f nginx-replicaset.yaml
</code></pre>
<p> </p>
<p>Pronto, o nosso <code>ReplicaSet</code> foi removido e todos os <code>Pods</code> que ele estava gerenciando também foram removidos.</p>
<p>Durante a nossa sessão, nós já aprendemos como criar um <code>ReplicaSet</code> e como ele funciona, mas ainda temos muito o que aprender, então vamos continuar.</p>
<p> </p>
<h3 id="o-daemonset">O DaemonSet</h3>
<p>Já sabemos o que é um <code>Pod</code>, um <code>Deployment</code> e um <code>ReplicaSet</code>, mas agora é a hora de conhecermos mais um objeto do <code>Kubernetes</code>, o <code>DaemonSet</code>.</p>
<p>O <code>DaemonSet</code> é um objeto que garante que todos os nós do cluster executem uma réplica de um <code>Pod</code>, ou seja, ele garante que todos os nós do cluster executem uma cópia de um <code>Pod</code>.</p>
<p>O <code>DaemonSet</code> é muito útil para executar <code>Pods</code> que precisam ser executados em todos os nós do cluster, como por exemplo, um <code>Pod</code> que faz o monitoramento de logs, ou um <code>Pod</code> que faz o monitoramento de métricas.</p>
<p>Alguns casos de uso de <code>DaemonSets</code> são:</p>
<ul>
<li>Execução de agentes de monitoramento, como o <code>Prometheus Node Exporter</code> ou o <code>Fluentd</code>.</li>
<li>Execução de um proxy de rede em todos os nós do cluster, como  <code>kube-proxy</code>, <code>Weave Net</code>, <code>Calico</code> ou <code>Flannel</code>.</li>
<li>Execução de agentes de segurança em cada nó do cluster, como  <code>Falco</code> ou <code>Sysdig</code>.</li>
</ul>
<p>Portanto, se nosso cluster possuir 3 nós, o <code>DaemonSet</code> vai garantir que todos os nós executem uma réplica do <code>Pod</code> que ele está gerenciando, ou seja, 3 réplicas do <code>Pod</code>.</p>
<p>Caso adicionemos mais um <code>node</code> ao cluster, o <code>DaemonSet</code> vai garantir que todos os nós executem uma réplica do <code>Pod</code> que ele está gerenciando, ou seja, 4 réplicas do <code>Pod</code>.</p>
<h4 id="criando-um-daemonset">Criando um DaemonSet</h4>
<p>Vamos para o nosso primeiro exemplo, vamos criar um <code>DaemonSet</code> que vai garantir que todos os nós do cluster executem uma réplica do <code>Pod</code> do <code>node-exporter</code>, que é um exporter de métricas do <code>Prometheus</code>.</p>
<p>Para isso, vamos criar um arquivo chamado <code>node-exporter-daemonset.yaml</code> e vamos adicionar o seguinte conteúdo.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># Versão da API do Kubernetes do objeto</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span> <span class="hljs-comment"># Tipo do objeto</span>
<span class="hljs-attr">metadata:</span> <span class="hljs-comment"># Informações sobre o objeto</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">node-exporter</span> <span class="hljs-comment"># Nome do objeto</span>
<span class="hljs-attr">spec:</span> <span class="hljs-comment"># Especificação do objeto</span>
  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># Seletor do objeto</span>
    <span class="hljs-attr">matchLabels:</span> <span class="hljs-comment"># Labels que serão utilizadas para selecionar os Pods</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">node-exporter</span> <span class="hljs-comment"># Label que será utilizada para selecionar os Pods</span>
  <span class="hljs-attr">template:</span> <span class="hljs-comment"># Template do objeto</span>
    <span class="hljs-attr">metadata:</span> <span class="hljs-comment"># Informações sobre o objeto</span>
      <span class="hljs-attr">labels:</span> <span class="hljs-comment"># Labels que serão adicionadas aos Pods</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">node-exporter</span> <span class="hljs-comment"># Label que será adicionada aos Pods</span>
    <span class="hljs-attr">spec:</span> <span class="hljs-comment"># Especificação do objeto, no caso, a especificação do Pod</span>
      <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Habilita o uso da rede do host, usar com cuidado</span>
      <span class="hljs-attr">containers:</span> <span class="hljs-comment"># Lista de contêineres que serão executados no Pod</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">node-exporter</span> <span class="hljs-comment"># Nome do contêiner</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">prom/node-exporter:latest</span> <span class="hljs-comment"># Imagem do contêiner</span>
        <span class="hljs-attr">ports:</span> <span class="hljs-comment"># Lista de portas que serão expostas no contêiner</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9100</span> <span class="hljs-comment"># Porta que será exposta no contêiner</span>
          <span class="hljs-attr">hostPort:</span> <span class="hljs-number">9100</span> <span class="hljs-comment"># Porta que será exposta no host</span>
        <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment"># Lista de volumes que serão montados no contêiner, pois o node-exporter precisa de acesso ao /proc e /sys</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">proc</span> <span class="hljs-comment"># Nome do volume</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/host/proc</span> <span class="hljs-comment"># Caminho onde o volume será montado no contêiner</span>
          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Habilita o modo de leitura apenas</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">sys</span> <span class="hljs-comment"># Nome do volume </span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/host/sys</span> <span class="hljs-comment"># Caminho onde o volume será montado no contêiner</span>
          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Habilita o modo de leitura apenas</span>
      <span class="hljs-attr">volumes:</span> <span class="hljs-comment"># Lista de volumes que serão utilizados no Pod</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">proc</span> <span class="hljs-comment"># Nome do volume</span>
        <span class="hljs-attr">hostPath:</span> <span class="hljs-comment"># Tipo de volume </span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/proc</span> <span class="hljs-comment"># Caminho do volume no host</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">sys</span> <span class="hljs-comment"># Nome do volume</span>
        <span class="hljs-attr">hostPath:</span> <span class="hljs-comment"># Tipo de volume</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">/sys</span> <span class="hljs-comment"># Caminho do volume no host</span>
</code></pre>
<p> </p>
<p>Eu deixei o arquivo comentado para facilitar o entendimento, agora vamos criar o <code>DaemonSet</code> utilizando o arquivo de manifesto.</p>
<pre><code class="lang-bash">kubectl apply -f node-exporter-daemonset.yaml
</code></pre>
<p> </p>
<p>Agora vamos verificar se o <code>DaemonSet</code> foi criado.</p>
<pre><code class="lang-bash">kubectl get daemonset
</code></pre>
<p> </p>
<p>Como podemos ver, o <code>DaemonSet</code> foi criado com sucesso.</p>
<pre><code class="lang-bash">NAME            DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
node-exporter   2         2         2       2            2           &lt;none&gt;          5m24s
</code></pre>
<p> </p>
<p>Caso você queira verificar os <code>Pods</code> que o <code>DaemonSet</code> está gerenciando, basta executar o comando abaixo.</p>
<pre><code class="lang-bash">kubectl get pods -l app=node-exporter
</code></pre>
<p> </p>
<p>Somente para lembrar, estamos utilizando o parâmetro <code>-l</code> para filtrar os <code>Pods</code> que possuem a label <code>app=node-exporter</code>, que é o caso do nosso <code>DaemonSet</code>.</p>
<p>Como podemos ver, o <code>DaemonSet</code> está gerenciando 2 <code>Pods</code>, um em cada nó do cluster.</p>
<pre><code class="lang-bash">NAME                  READY   STATUS    RESTARTS   AGE
node-exporter-k8wp9   1/1     Running   0          6m14s
node-exporter-q8zvw   1/1     Running   0          6m14s
</code></pre>
<p> </p>
<p>Os nossos <code>Pods</code> do <code>node-exporter</code> foram criados com sucesso, agora vamos verificar se eles estão sendo executados em todos os nós do cluster.</p>
<pre><code class="lang-bash">kubectl get pods -o wide -l app=node-exporter
</code></pre>
<p> </p>
<p>Com o comando acima, podemos ver em qual nó cada <code>Pod</code> está sendo executado.</p>
<pre><code class="lang-bash">NAME                                READY   STATUS    RESTARTS   AGE     IP               NODE                            NOMINATED NODE   READINESS GATES
node-exporter-k8wp9                 1/1     Running   0          3m49s   192.168.8.145    ip-192-168-8-145.ec2.internal   &lt;none&gt;           &lt;none&gt;
node-exporter-q8zvw                 1/1     Running   0          3m49s   192.168.55.68    ip-192-168-55-68.ec2.internal   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p> </p>
<p>Como podemos ver, os <code>Pods</code> do <code>node-exporter</code> estão sendo executados em todos os dois nós do cluster.</p>
<p>Para ver os detalhes do <code>DaemonSet</code>, basta executar o comando abaixo.</p>
<pre><code class="lang-bash">kubectl describe daemonset node-exporter
</code></pre>
<p> </p>
<p>O comando acima vai retornar uma saída parecida com a abaixo.</p>
<pre><code class="lang-bash">Name:           node-exporter
Selector:       app=node-exporter
Node-Selector:  &lt;none&gt;
Labels:         &lt;none&gt;
Annotations:    deprecated.daemonset.template.generation: 1
Desired Number of Nodes Scheduled: 2
Current Number of Nodes Scheduled: 2
Number of Nodes Scheduled with Up-to-date Pods: 2
Number of Nodes Scheduled with Available Pods: 2
Number of Nodes Misscheduled: 0
Pods Status:  2 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  app=node-exporter
  Containers:
   node-exporter:
    Image:        prom/node-exporter:latest
    Port:         9100/TCP
    Host Port:    9100/TCP
    Environment:  &lt;none&gt;
    Mounts:
      /host/proc from proc (ro)
      /host/sys from sys (ro)
  Volumes:
   proc:
    Type:          HostPath (bare host directory volume)
    Path:          /proc
    HostPathType:  
   sys:
    Type:          HostPath (bare host directory volume)
    Path:          /sys
    HostPathType:  
Events:
  Type    Reason            Age   From                  Message
  ----    ------            ----  ----                  -------
  Normal  SuccessfulCreate  9m6s  daemonset-controller  Created pod: node-exporter-q8zvw
  Normal  SuccessfulCreate  9m6s  daemonset-controller  Created pod: node-exporter-k8wp9
</code></pre>
<p> </p>
<p>Na saída acima, podemos ver algumas informações bem importantes relacionadas ao <code>DaemonSet</code>, como por exemplo, o número de nós que o <code>DaemonSet</code> está gerenciando, o número de <code>Pods</code> que estão sendo executados em cada nó, etc.</p>
<h4 id="criando-um-daemonset-utilizando-o-comando-kubectl-create">Criando um DaemonSet utilizando o comando kubectl create</h4>
<p>Você ainda pode criar um <code>DaemonSet</code> utilizando o comando <code>kubectl create</code>, mas eu prefiro utilizar o arquivo de manifesto, pois assim eu consigo versionar o meu <code>DaemonSet</code>, mas caso você queira criar um <code>DaemonSet</code> utilizando o comando <code>kubectl create</code>, basta executar o comando abaixo.</p>
<pre><code class="lang-bash">kubectl create daemonset node-exporter --image=prom/node-exporter:latest --port=9100 --host-port=9100
</code></pre>
<p> </p>
<p>Ficaram faltando alguns parâmetros no comando acima, mas eu deixei assim para facilitar o entendimento, caso você queira ver todos os parâmetros que podem ser utilizados no comando <code>kubectl create daemonset</code>, basta executar o comando abaixo.</p>
<pre><code class="lang-bash">kubectl create daemonset --<span class="hljs-built_in">help</span>
</code></pre>
<p> </p>
<p>Eu gosto de utilizar o <code>kubectl create</code> somente para criar um arquivo exemplo, para que eu possa me basear na hora de criar o meu arquivo de manifesto, mas caso você queira criar um manifesto para criar <code>DaemonSet</code> utilizando o comando <code>kubectl create</code>, basta executar o comando abaixo.</p>
<pre><code class="lang-bash">kubectl create daemonset node-exporter --image=prom/node-exporter:latest --port=9100 --host-port=9100 -o yaml --dry-run=client &gt; node-exporter-daemonset.yaml
</code></pre>
<p> </p>
<p>Simples assim! Vou te explicar o que está acontecendo no comando acima.</p>
<ul>
<li><code>kubectl create daemonset node-exporter</code> - Cria um <code>DaemonSet</code> chamado <code>node-exporter</code>.</li>
<li><code>--image=prom/node-exporter:latest</code> - Utiliza a imagem <code>prom/node-exporter:latest</code> para criar os <code>Pods</code>.</li>
<li><code>--port=9100</code> - Define a porta <code>9100</code> para o <code>Pod</code>.</li>
<li><code>--host-port=9100</code> - Define a porta <code>9100</code> para o nó.</li>
<li><code>-o yaml</code> - Define o formato do arquivo de manifesto como <code>yaml</code>.</li>
<li><code>--dry-run=client</code> - Executa o comando sem criar o <code>DaemonSet</code>, somente simula a criação do <code>DaemonSet</code>.</li>
<li><code>&gt; node-exporter-daemonset.yaml</code> - Redireciona a saída do comando para o arquivo <code>node-exporter-daemonset.yaml</code>.</li>
</ul>
<p>Ficou mais simples, certo?</p>
<h4 id="aumentando-um-node-no-cluster">Aumentando um node no cluster</h4>
<p>Agora que já sabemos como criar um <code>DaemonSet</code>, vamos aumentar o número de nós do nosso cluster.</p>
<p>Nós estamos com duas réplicas nesse momento.</p>
<pre><code class="lang-bash">kubectl get nodes
</code></pre>
<p> </p>
<pre><code class="lang-bash">NAME                             STATUS   ROLES    AGE    VERSION
ip-192-168-55-68.ec2.internal    Ready    &lt;none&gt;   113m   v1.23.16-eks-48e63af
ip-192-168-8-145.ec2.internal    Ready    &lt;none&gt;   113m   v1.23.16-eks-48e63af
</code></pre>
<p> </p>
<p>Vamos aumentar o número de nós para 3.</p>
<p>Eu estou utilizando o <code>eksctl</code> para criar o cluster, então eu vou utilizar o comando <code>eksctl scale nodegroup</code> para aumentar o número de nós do cluster, mas caso você esteja utilizando outro gerenciador de cluster, você pode utilizar o comando que preferir para aumentar o número de nós do cluster.</p>
<pre><code class="lang-bash">eksctl scale nodegroup --cluster=eks-cluster --nodes 3 --name eks-cluster-nodegroup
</code></pre>
<p> </p>
<pre><code class="lang-bash">2023-03-11 13:31:48 [ℹ]  scaling nodegroup <span class="hljs-string">&quot;eks-cluster-nodegroup&quot;</span> <span class="hljs-keyword">in</span> cluster eks-cluster
2023-03-11 13:31:49 [ℹ]  waiting <span class="hljs-keyword">for</span> scaling of nodegroup <span class="hljs-string">&quot;eks-cluster-nodegroup&quot;</span> to complete
2023-03-11 13:33:17 [ℹ]  nodegroup successfully scaled
</code></pre>
<p> </p>
<p>Vamos verificar se o node foi adicionado ao cluster.</p>
<pre><code class="lang-bash">kubectl get nodes
</code></pre>
<p> </p>
<pre><code class="lang-bash">NAME                             STATUS   ROLES    AGE    VERSION
ip-192-168-45-194.ec2.internal   Ready    &lt;none&gt;   47s    v1.23.16-eks-48e63af
ip-192-168-55-68.ec2.internal    Ready    &lt;none&gt;   113m   v1.23.16-eks-48e63af
ip-192-168-8-145.ec2.internal    Ready    &lt;none&gt;   113m   v1.23.16-eks-48e63af
</code></pre>
<p> </p>
<p>Pronto, agora nós temos 3 nós no cluster.</p>
<p>Mas a pergunta que não quer calar é: O <code>DaemonSet</code> criou um <code>Pod</code> no novo nó?</p>
<p>Vamos verificar.</p>
<pre><code class="lang-bash">kubectl get pods -o wide -l app=node-exporter
</code></pre>
<p> </p>
<pre><code class="lang-bash">NAME                  READY   STATUS    RESTARTS   AGE   IP               NODE                             NOMINATED NODE   READINESS GATES
node-exporter-k8wp9   1/1     Running   0          20m   192.168.8.145    ip-192-168-8-145.ec2.internal    &lt;none&gt;           &lt;none&gt;
node-exporter-q8zvw   1/1     Running   0          20m   192.168.55.68    ip-192-168-55-68.ec2.internal    &lt;none&gt;           &lt;none&gt;
node-exporter-xffgq   1/1     Running   0          70s   192.168.45.194   ip-192-168-45-194.ec2.internal   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p> </p>
<p>Parece que temos um novo <code>Pod</code> no nó <code>ip-192-168-45-194.ec2.internal</code>, mas vamos verificar se o <code>DaemonSet</code> está gerenciando esse nó.</p>
<pre><code class="lang-bash">kubectl describe daemonset node-exporter
</code></pre>
<p> </p>
<pre><code class="lang-bash">Desired Number of Nodes Scheduled: 3
Current Number of Nodes Scheduled: 3
Number of Nodes Scheduled with Up-to-date Pods: 3
Number of Nodes Scheduled with Available Pods: 3
Number of Nodes Misscheduled: 0
Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed
</code></pre>
<p> </p>
<p>Tudo em paz e harmonia, o <code>DaemonSet</code> está gerenciando o novo <code>Pod</code> no novo <code>node</code>.
E claro, se por algum motivo o <code>Pod</code> cair, o <code>DaemonSet</code> vai criar um novo <code>Pod</code> no mesmo <code>node</code>. 
E claro versão 2, se a quantidade de nodes diminuir, o <code>DaemonSet</code> vai remover os <code>Pods</code> que estão em excesso. E bem lembrado, deixa eu dimunuir o número de nós do cluster para salvar alguns doletas.</p>
<pre><code class="lang-bash">eksctl scale nodegroup --cluster=eks-cluster --nodes 2 --name eks-cluster-nodegroup
</code></pre>
<p> </p>
<h4 id="removendo-um-daemonset">Removendo um DaemonSet</h4>
<p>Para remover o <code>DaemonSet</code> é bem simples, basta executar o comando <code>kubectl delete daemonset &lt;nome-do-daemonset&gt;</code>.</p>
<pre><code class="lang-bash">kubectl delete daemonset node-exporter
</code></pre>
<p> </p>
<pre><code class="lang-bash">daemonset.apps <span class="hljs-string">&quot;node-exporter&quot;</span> deleted
</code></pre>
<p> </p>
<p>Ou ainda você pode remover o <code>DaemonSet</code> através do manifesto.</p>
<pre><code class="lang-bash">kubectl delete -f node-exporter-daemonset.yaml
</code></pre>
<p> </p>
<p>Simples assim!</p>
<p>Acho que o assunto <code>DaemonSet</code> já está bem claro. Ainda iremos ver todos esses objetos que vimos até aqui diversas vezes durante a nossa jornada, então não se preocupe pois iremos praticar muito mais.</p>
<p> </p>
<h3 id="as-probes-do-kubernetes">As Probes do Kubernetes</h3>
<p>Antes de seguir, eu queria trazer algo novo além dos dois novos objetos que você já aprendeu no dia de hoje.
Eu queria que você saisse do dia de hoje com a segurança que você e capaz de criar um <code>Pod</code>, um <code>Deployment</code>, um <code>ReplicaSet</code> ou um <code>DaemonSet</code>, mas também com a segurança que você pode monitorar o seus suas aplicações que estão rodando dentro do cluster de maneira efetiva e utilizando recursos que o Kubernetes já nos disponibiliza.</p>
<h4 id="o-que-são-as-probes">O que são as Probes?</h4>
<p>As probes são uma forma de você monitorar o seu <code>Pod</code> e saber se ele está em um estado saudável ou não. Com elas é possível assegurar que seus <code>Pods</code> estão rodando e respondendo de maneira correta, e mais do que isso, que o Kubernetes está testando o que está sendo executado dentro do seu <code>Pod</code>.</p>
<p>Hoje nós temos disponíveis três tipos de probes, a <code>livenessProbe</code>, a <code>readinessProbe</code> e a <code>startupProbe</code>. Vamos ver no detalhe cada uma delas.</p>
<h4 id="liveness-probe">Liveness Probe</h4>
<p>A <code>livenessProbe</code> é a nossa probe de verificação de integridade, o que ela faz é verificar se o que está rodando dentro do <code>Pod</code> está saudável. O que fazemos é criar uma forma de testar se o que temos dentro do <code>Pod</code> está respondendo conforme esperado. Se por acaso o teste falhar, o <code>Pod</code> será reiniciado.</p>
<p>Para ficar mais claro, vamos mais uma vez utilizar o exemplo com o <code>Nginx</code>. Gosto de usar o <code>Nginx</code> como exemplo, pois sei que toda pessoa já o conhece, e assim, fica muito mais fácil de entender o que está acontecendo. Afinal, você está aqui para aprender Kubernetes, e se for com algo que você já conhece, fica muito mais fácil de entender.</p>
<p>Bem, vamos lá, hora de criar um novo <code>Deployment</code> com o <code>Nginx</code>, vamos utilizar o exemplo que já utilizamos quando aprendemos sobre o <code>Deployment</code>.</p>
<p>Para isso, crie um arquivo chamado <code>nginx-liveness.yaml</code> e cole o seguinte conteúdo.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.2</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
        <span class="hljs-attr">livenessProbe:</span> <span class="hljs-comment"># Aqui é onde vamos adicionar a nossa livenessProbe</span>
          <span class="hljs-attr">tcpSocket:</span> <span class="hljs-comment"># Aqui vamos utilizar o tcpSocket, onde vamos se conectar ao container através do protocolo TCP</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># Qual porta TCP vamos utilizar para se conectar ao container</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># Quantos segundos vamos esperar para executar a primeira verificação</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># A cada quantos segundos vamos executar a verificação</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># Quantos segundos vamos esperar para considerar que a verificação falhou</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># Quantos falhas consecutivas vamos aceitar antes de reiniciar o container</span>
</code></pre>
<p> </p>
<p>Com isso temos algumas coisas novas, e utilizamos apenas uma <code>probe</code> que é a <code>livenessProbe</code>. </p>
<p>O que declaramos com a regra acima é que queremos testar se o <code>Pod</code> está respondendo através do protocolo TCP, através da opção <code>tcpSocket</code>, na porta 80 que foi definida pela opção <code>port</code>. E também definimos que queremos esperar 10 segundos para executar a primeira verificação utilizando <code>initialDelaySeconds</code> e por conta da <code>periodSeconds</code>falamos que queremos que a cada 10 segundos seja realizada a verificação. Caso a verificação falhe, vamos esperar 5 segundos, por conta da <code>timeoutSeconds</code>, para tentar novamente, e como utilizamos o <code>failureThreshold</code>, se falhar mais 3 vezes, vamos reiniciar o <code>Pod</code>.</p>
<p>Ficou mais claro? Vamos para mais um exemplo.</p>
<p>Vamos imaginar que agora não queremos mais utilizar o <code>tcpSocket</code>, mas sim o <code>httpGet</code> para tentar acessar um endpoint dentro do nosso <code>Pod</code>.</p>
<p>Para isso, vamos alterar o nosso <code>nginx-deployment.yaml</code> para o seguinte.</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.2</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
        <span class="hljs-attr">livenessProbe:</span> <span class="hljs-comment"># Aqui é onde vamos adicionar a nossa livenessProbe</span>
          <span class="hljs-attr">httpGet:</span> <span class="hljs-comment"># Aqui vamos utilizar o httpGet, onde vamos se conectar ao container através do protocolo HTTP</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># Qual o endpoint que vamos utilizar para se conectar ao container</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># Qual porta TCP vamos utilizar para se conectar ao container</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># Quantos segundos vamos esperar para executar a primeira verificação</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># A cada quantos segundos vamos executar a verificação</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># Quantos segundos vamos esperar para considerar que a verificação falhou</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># Quantos falhas consecutivas vamos aceitar antes de reiniciar o container</span>
</code></pre>
<p> </p>
<p>Perceba que agora somente mudamos algumas coisas, apesar de seguir com o mesmo objetivo, que é verificar se o <code>Nginx</code> está respondendo corretamente, mudamos como iremos testar isso. Agora estamos utilizando o <code>httpGet</code> para testar se o <code>Nginx</code> está respondendo corretamente através do protocolo HTTP, e para isso, estamos utilizando o endpoint <code>/</code> e a porta 80.</p>
<p>O que temos de novo aqui é a opção <code>path</code>, que é o endpoint que vamos utilizar para testar se o <code>Nginx</code> está respondendo corretamente, e claro, a <code>httpGet</code> é a forma como iremos realizar o nosso teste, através do protocolo HTTP.</p>
<p> </p>
<p>Escolha qual dois dois exemplos você quer utilizar, e crie o seu <code>Deployment</code> através do comando abaixo.</p>
<pre><code class="lang-bash">kubectl apply -f nginx-deployment.yaml
</code></pre>
<p> </p>
<p>Para verificar se o <code>Deployment</code> foi criado corretamente, execute o comando abaixo.</p>
<pre><code class="lang-bash">kubectl get deployments
</code></pre>
<p> </p>
<p>Você deve ver algo parecido com isso.</p>
<pre><code class="lang-bash">NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-7557d7fc6c-dx48d   1/1     Running   0          14s
nginx-deployment-7557d7fc6c-tbk4w   1/1     Running   0          12s
nginx-deployment-7557d7fc6c-wv876   1/1     Running   0          16s
</code></pre>
<p> </p>
<p>Para que você possa ver mais detalhes sobre o seu <code>Pod</code> e saber se a nossa probe está funcionando corretamente, vamos utilizar o comando abaixo.</p>
<pre><code class="lang-bash">kubectl describe pod nginx-deployment-7557d7fc6c-dx48d
</code></pre>
<p> </p>
<p>A saída deve ser parecida com essa.</p>
<pre><code class="lang-bash">Name:             nginx-deployment-589d6fc888-42fmg
Namespace:        default
Priority:         0
Service Account:  default
Node:             ip-192-168-39-119.ec2.internal/192.168.39.119
Start Time:       Thu, 16 Mar 2023 18:49:53 +0100
Labels:           app=nginx-deployment
                  pod-template-hash=589d6fc888
Annotations:      kubernetes.io/psp: eks.privileged
Status:           Running
IP:               192.168.49.40
IPs:
  IP:           192.168.49.40
Controlled By:  ReplicaSet/nginx-deployment-589d6fc888
Containers:
  nginx:
    Container ID:   docker://f7fc28a1fafbf53471ba144d4fb48bc029d289d93b3565b839ae89a1f38cd894
    Image:          nginx:1.19.2
    Image ID:       docker-pullable://nginx@sha256:c628b67d21744fce822d22fdcc0389f6bd763daac23a6b77147d0712ea7102d0
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Thu, 16 Mar 2023 18:49:59 +0100
    Ready:          True
    Restart Count:  0
    Limits:
      cpu:     500m
      memory:  256Mi
    Requests:
      cpu:        250m
      memory:     128Mi
    Liveness:     http-get http://:80/ delay=10s timeout=5s period=10s <span class="hljs-comment">#success=1 #failure=3</span>
    Environment:  &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-8srlq (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  kube-api-access-8srlq:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             <span class="hljs-literal">true</span>
QoS Class:                   Burstable
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists <span class="hljs-keyword">for</span> 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists <span class="hljs-keyword">for</span> 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  21s   default-scheduler  Successfully assigned default/nginx-deployment-589d6fc888-42fmg to ip-192-168-39-119.ec2.internal
  Normal  Pulling    20s   kubelet            Pulling image <span class="hljs-string">&quot;nginx:1.19.2&quot;</span>
  Normal  Pulled     15s   kubelet            Successfully pulled image <span class="hljs-string">&quot;nginx:1.19.2&quot;</span> <span class="hljs-keyword">in</span> 4.280120301s (4.280125621s including waiting)
  Normal  Created    15s   kubelet            Created container nginx
  Normal  Started    15s   kubelet            Started container nginx
</code></pre>
<p> </p>
<p>Aqui temos a informação mais importante para nós nesse momento:</p>
<pre><code class="lang-bash">    Liveness:     http-get http://:80/ delay=10s timeout=5s period=10s <span class="hljs-comment">#success=1 #failure=3</span>
</code></pre>
<p> </p>
<p>A saída acima é parte da saída do comando <code>kubectl describe pod</code>. Tudo funcionando maravilhosamente bem.</p>
<p>Agora vamos fazer o seguinte, vamos alterar o nosso <code>Deployment</code>, para que a nossa probe falhe. Para isso vamos alterar o <code>endpoint</code> que estamos utilizando. Vamos alterar o <code>path</code> para <code>/giropops</code>.</p>
<p> </p>
<pre><code class="lang-yaml"><span class="hljs-string">```yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.2</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
        <span class="hljs-attr">livenessProbe:</span> <span class="hljs-comment"># Aqui é onde vamos adicionar a nossa livenessProbe</span>
          <span class="hljs-attr">httpGet:</span> <span class="hljs-comment"># Aqui vamos utilizar o httpGet, onde vamos se conectar ao container através do protocolo HTTP</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">/giropops</span> <span class="hljs-comment"># Qual o endpoint que vamos utilizar para se conectar ao container</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># Qual porta TCP vamos utilizar para se conectar ao container</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># Quantos segundos vamos esperar para executar a primeira verificação</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># A cada quantos segundos vamos executar a verificação</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># Quantos segundos vamos esperar para considerar que a verificação falhou</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># Quantos falhas consecutivas vamos aceitar antes de reiniciar o container</span>
</code></pre>
<p> </p>
<p>Vamos aplicar as alterações no nosso <code>Deployment</code>:</p>
<pre><code class="lang-bash">kubectl apply -f deployment.yaml
</code></pre>
<p> </p>
<p>Depois de um tempo, você perceberá que o Kubernetes finalizou a atualização do nosso <code>Deployment</code>. 
Se você aguardar um pouco mais, você irá perceber que os <code>Pods</code> estã̀o sendo reiniciados com frequência.</p>
<p>Tudo isso porque a nossa <code>livenessProbe</code> está falhando, afinal o nosso <code>endpoint</code> está errado.</p>
<p>Podemos ver mais detalhes sobre o que está acontecendo na saída do comando <code>kubectl describe pod</code>:</p>
<pre><code class="lang-bash">kubectl describe pod nginx-deployment-7557d7fc6c-dx48d
</code></pre>
<p> </p>
<pre><code class="lang-bash">Name:             nginx-deployment-7557d7fc6c-dx48d
Namespace:        default
Priority:         0
Service Account:  default
Node:             ip-192-168-39-119.ec2.internal/192.168.39.119
Start Time:       Thu, 16 Mar 2023 18:51:00 +0100
Labels:           app=nginx-deployment
                  pod-template-hash=7557d7fc6c
Annotations:      kubernetes.io/psp: eks.privileged
Status:           Running
IP:               192.168.44.84
IPs:
  IP:           192.168.44.84
Controlled By:  ReplicaSet/nginx-deployment-7557d7fc6c
Containers:
  nginx:
    Container ID:   docker://c070d9c08bec40ad14562512d7bd8507a44279a327f1b3ecac1621da7ccf21b4
    Image:          nginx:1.19.2
    Image ID:       docker-pullable://nginx@sha256:c628b67d21744fce822d22fdcc0389f6bd763daac23a6b77147d0712ea7102d0
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Thu, 16 Mar 2023 18:51:41 +0100
    Last State:     Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Thu, 16 Mar 2023 18:51:02 +0100
      Finished:     Thu, 16 Mar 2023 18:51:40 +0100
    Ready:          True
    Restart Count:  1
    Limits:
      cpu:     500m
      memory:  256Mi
    Requests:
      cpu:        250m
      memory:     128Mi
    Liveness:     http-get http://:80/giropops delay=10s timeout=5s period=10s <span class="hljs-comment">#success=1 #failure=3</span>
    Environment:  &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-4sk2f (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  kube-api-access-4sk2f:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             <span class="hljs-literal">true</span>
QoS Class:                   Burstable
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists <span class="hljs-keyword">for</span> 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists <span class="hljs-keyword">for</span> 300s
Events:
  Type     Reason     Age               From               Message
  ----     ------     ----              ----               -------
  Normal   Scheduled  44s               default-scheduler  Successfully assigned default/nginx-deployment-7557d7fc6c-dx48d to ip-192-168-39-119.ec2.internal
  Normal   Pulled     4s (x2 over 43s)  kubelet            Container image <span class="hljs-string">&quot;nginx:1.19.2&quot;</span> already present on machine
  Normal   Created    4s (x2 over 43s)  kubelet            Created container nginx
  Warning  Unhealthy  4s (x3 over 24s)  kubelet            Liveness probe failed: HTTP probe failed with statuscode: 404
  Normal   Killing    4s                kubelet            Container nginx failed liveness probe, will be restarted
  Normal   Started    3s (x2 over 42s)  kubelet            Started container nginx
</code></pre>
<p> </p>
<p>Na última parte da saída do comando <code>kubectl describe pod</code>, você pode ver que o Kubernetes está tentando executar a nossa <code>livenessProbe</code> e ela está falhando, inclusive ele mostra a quantidade de vezes que ele tentou executar a <code>livenessProbe</code> e falhou, e com isso, ele reiniciou o nosso <code>Pod</code>.</p>
<p> </p>
<p>Acho que agora ficou bem mais claro como a <code>livenessProbe</code> funciona, então é hora de partir para a próxima probe, a <code>readinessProbe</code>.</p>
<p> </p>
<h4 id="readiness-probe">Readiness Probe</h4>
<p>A <code>readinessProbe</code> é uma forma de o Kubernetes verificar se o seu container está pronto para receber tráfego, se ele está pronto para receber requisições vindas de fora.</p>
<p>Essa é a nossa probe de leitura, ela fica verificando se o nosso container está pronto para receber requisições, e se estiver pronto, ele irá receber requisições, caso contrário, ele não irá receber requisições, pois será removido do <code>endpoint</code> do serviço, fazendo com que o tráfego não chegue até ele.</p>
<p>Ainda iremos ver o que é <code>service</code> e <code>endpoint</code>, mas por enquanto, basta saber que o <code>endpoint</code> é o endereço que o nosso <code>service</code> irá usar para acessar o nosso <code>Pod</code>. Mas vamos ter um dia inteiro para falar sobre <code>service</code> e <code>endpoint</code>, então, relaxa.</p>
<p> </p>
<p>Voltando ao assunto, a nossa probe da vez irá garantir que o nosso <code>Pod</code>está saudável para receber requisições.</p>
<p>Vamos para um exemplo para ficar mais claro.</p>
<p>Para o nosso exemplo, vamos criar um arquivo chamado <code>nginx-readiness.yaml</code> e vamos colocar o seguinte conteúdo:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.2</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
        <span class="hljs-attr">readinessProbe:</span> <span class="hljs-comment"># Onde definimos a nossa probe de leitura</span>
          <span class="hljs-attr">httpGet:</span> <span class="hljs-comment"># O tipo de teste que iremos executar, neste caso, iremos executar um teste HTTP</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># O caminho que iremos testar</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># A porta que iremos testar</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># O tempo que iremos esperar para executar a primeira vez a probe</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># De quanto em quanto tempo iremos executar a probe</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># O tempo que iremos esperar para considerar que a probe falhou</span>
          <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># O número de vezes que a probe precisa passar para considerar que o container está pronto</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># O número de vezes que a probe precisa falhar para considerar que o container não está pronto</span>
</code></pre>
<p> </p>
<p>Vamos ver se os nossos <code>Pods</code> estão rodando:</p>
<pre><code class="lang-bash">kubectl get pods
</code></pre>
<p> </p>
<pre><code class="lang-bash">NAME                               READY   STATUS    RESTARTS   AGE
nginx-deployment-fbdc9b65f-trnnz   0/1     Running   0          6s
nginx-deployment-fbdc9b65f-z8n4m   0/1     Running   0          6s
nginx-deployment-fbdc9b65f-zn8zh   0/1     Running   0          6s
</code></pre>
<p> </p>
<p>Podemos ver que agora os <code>Pods</code> demoram um pouco mais para ficarem prontos, pois estamos executando a nossa <code>readinessProbe</code>, e por esse motivo temos que aguardar os 10 segundos inicias que definimos para que seja executada a primeira vez a nossa probe, lembra?</p>
<p>Se você aguardar um pouco, você verá que os <code>Pods</code> irão ficar prontos, e você pode ver isso executando o comando:</p>
<pre><code class="lang-bash">kubectl get pods
</code></pre>
<p> </p>
<pre><code class="lang-bash">NAME                               READY   STATUS    RESTARTS   AGE
nginx-deployment-fbdc9b65f-trnnz   1/1     Running   0          30s
nginx-deployment-fbdc9b65f-z8n4m   1/1     Running   0          30s
nginx-deployment-fbdc9b65f-zn8zh   1/1     Running   0          30s
</code></pre>
<p> </p>
<p>Pronto, como mágica agora os nossos <code>Pods</code> estão prontos para receber requisições.</p>
<p>Vamos dar uma olhada no <code>describe</code> do nosso <code>Pod</code>:</p>
<pre><code class="lang-bash">kubectl describe pod nginx-deployment-fbdc9b65f-trnnz
</code></pre>
<p> </p>
<pre><code class="lang-bash">Name:             nginx-deployment-fbdc9b65f-trnnz
Namespace:        default
Priority:         0
Service Account:  default
Node:             ip-192-168-39-119.ec2.internal/192.168.39.119
Start Time:       Thu, 16 Mar 2023 19:10:07 +0100
Labels:           app=nginx-deployment
                  pod-template-hash=fbdc9b65f
Annotations:      kubernetes.io/psp: eks.privileged
Status:           Running
IP:               192.168.49.40
IPs:
  IP:           192.168.49.40
Controlled By:  ReplicaSet/nginx-deployment-fbdc9b65f
Containers:
  nginx:
    Container ID:   docker://09538e27e29c5c649efa88fe148336abd5a47dd4e5a8d32b40b268fb1818dfc4
    Image:          nginx:1.19.2
    Image ID:       docker-pullable://nginx@sha256:c628b67d21744fce822d22fdcc0389f6bd763daac23a6b77147d0712ea7102d0
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Thu, 16 Mar 2023 19:10:08 +0100
    Ready:          True
    Restart Count:  0
    Limits:
      cpu:     500m
      memory:  256Mi
    Requests:
      cpu:        250m
      memory:     128Mi
    Readiness:    http-get http://:80/ delay=10s timeout=5s period=10s <span class="hljs-comment">#success=2 #failure=3</span>
    Environment:  &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-zpfvb (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  kube-api-access-zpfvb:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             <span class="hljs-literal">true</span>
QoS Class:                   Burstable
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists <span class="hljs-keyword">for</span> 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists <span class="hljs-keyword">for</span> 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  60s   default-scheduler  Successfully assigned default/nginx-deployment-fbdc9b65f-trnnz to ip-192-168-39-119.ec2.internal
  Normal  Pulled     59s   kubelet            Container image <span class="hljs-string">&quot;nginx:1.19.2&quot;</span> already present on machine
  Normal  Created    59s   kubelet            Created container nginx
  Normal  Started    59s   kubelet            Started container nginx
</code></pre>
<p> </p>
<p>Pronto, a nossa probe está lá e funcionando, e com isso podemos garantir que os nossos <code>Pods</code> estão prontos para receber requisições.</p>
<p>Vamos mudar o nosso <code>path</code> para <code>/giropops</code> e ver o que acontece:</p>
<pre><code class="lang-yaml"><span class="hljs-string">...</span>
        <span class="hljs-attr">readinessProbe:</span> <span class="hljs-comment"># Onde definimos a nossa probe de leitura</span>
          <span class="hljs-attr">httpGet:</span> <span class="hljs-comment"># O tipo de teste que iremos executar, neste caso, iremos executar um teste HTTP</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">/giropops</span> <span class="hljs-comment"># O caminho que iremos testar</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># A porta que iremos testar</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># O tempo que iremos esperar para executar a primeira vez a probe</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># De quanto em quanto tempo iremos executar a probe</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># O tempo que iremos esperar para considerar que a probe falhou</span>
          <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># O número de vezes que a probe precisa passar para considerar que o container está pronto</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># O número de vezes que a probe precisa falhar para considerar que o container não está pronto</span>
</code></pre>
<p> </p>
<pre><code class="lang-bash">kubectl apply -f nginx-deployment.yaml
</code></pre>
<p> </p>
<pre><code class="lang-bash">deployment.apps/nginx-deployment configured
</code></pre>
<p> </p>
<p>Muito bom, agora vamos ver o resultado dessa bagunça:</p>
<pre><code class="lang-bash">kubectl get pods
</code></pre>
<p> </p>
<p>Nesse ponto você pode ver que o Kubernetes está tentando realizar a atualização do nosso <code>Deployment</code>, mas não está conseguindo, pois no primeiro <code>Pod</code> que ele tentou atualizar, a probe falhou.</p>
<pre><code class="lang-bash">NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-5fd6c688d8-kjf8d   0/1     Running   0          93s
nginx-deployment-fbdc9b65f-trnnz    1/1     Running   0          9m21s
nginx-deployment-fbdc9b65f-z8n4m    1/1     Running   0          9m21s
nginx-deployment-fbdc9b65f-zn8zh    1/1     Running   0          9m21s
</code></pre>
<p> </p>
<p>Vamos ver o nosso <code>rollout</code>:</p>
<pre><code class="lang-bash">kubectl rollout status deployment/nginx-deployment
</code></pre>
<p> </p>
<pre><code class="lang-bash">Waiting <span class="hljs-keyword">for</span> deployment <span class="hljs-string">&quot;nginx-deployment&quot;</span> rollout to finish: 1 out of 3 new replicas have been updated...
</code></pre>
<p> </p>
<p>Mesmo depois de algum tempo o nosso <code>rollout</code> não terminou, ele continua esperando a nossa probe passar.</p>
<p>Podemos ver os detalhes do <code>Pod</code> que está com problema:</p>
<pre><code class="lang-bash">kubectl describe pod nginx-deployment-5fd6c688d8-kjf8d
</code></pre>
<p> </p>
<pre><code class="lang-bash">Events:
  Type     Reason     Age                   From               Message
  ----     ------     ----                  ----               -------
  Normal   Scheduled  4m4s                  default-scheduler  Successfully assigned default/nginx-deployment-5fd6c688d8-kjf8d to ip-192-168-8-176.ec2.internal
  Normal   Pulled     4m3s                  kubelet            Container image <span class="hljs-string">&quot;nginx:1.19.2&quot;</span> already present on machine
  Normal   Created    4m3s                  kubelet            Created container nginx
  Normal   Started    4m3s                  kubelet            Started container nginx
  Warning  Unhealthy  34s (x22 over 3m44s)  kubelet            Readiness probe failed: HTTP probe failed with statuscode: 404
</code></pre>
<p> </p>
<p>Eu somente colei a parte final da saída, que é a parte mais interessante para esse momento. É nessa parte que podemos ver que o nosso <code>Pod</code> não está saudável, e por isso o Kubernetes não está conseguindo atualizar o nosso <code>Deployment</code>.</p>
<p> </p>
<h4 id="startup-probe">Startup Probe</h4>
<p>Chegou a hora de falar sobre a probe, que na minha humilde opinião, é a menos utilizada, mas que é muito importante, a <code>startupProbe</code>.</p>
<p>Ela é a responsável por verificar se o nosso container foi inicializado corretamente, e se ele está pronto para receber requisições.</p>
<p>Ele é muito parecido com a <code>readinessProbe</code>, mas a diferença é que a <code>startupProbe</code> é executada apenas uma vez no começo da vida do nosso container, e a <code>readinessProbe</code> é executada de tempos em tempos.</p>
<p>Para entender melhor, vamos ver um exemplo criando um arquivo chamado <code>nginx-startup.yaml</code>:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.2</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
        <span class="hljs-attr">startupProbe:</span> <span class="hljs-comment"># Onde definimos a nossa probe de inicialização</span>
          <span class="hljs-attr">httpGet:</span> <span class="hljs-comment"># O tipo de teste que iremos executar, neste caso, iremos executar um teste HTTP</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># O caminho que iremos testar</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># A porta que iremos testar</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># O tempo que iremos esperar para executar a primeira vez a probe</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># De quanto em quanto tempo iremos executar a probe</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># O tempo que iremos esperar para considerar que a probe falhou</span>
          <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># O número de vezes que a probe precisa passar para considerar que o container está pronto</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># O número de vezes que a probe precisa falhar para considerar que o container não está pronto</span>
</code></pre>
<p> </p>
<p>Agora vamos aplicar a nossa configuração:</p>
<pre><code class="lang-bash">kubectl apply -f nginx-startup.yaml
</code></pre>
<p> </p>
<p>Quando você tentar aplicar, receberá um erro, pois a <code>successThreshold</code> não pode ser maior que 1, pois a <code>startupProbe</code> é executada apenas uma vez, lembra?</p>
<p>Da mesma forma o <code>failureThreshold</code> não pode ser maior que 1, então vamos alterar o nosso arquivo para:</p>
<pre><code class="lang-yaml"><span class="hljs-string">...</span>
        <span class="hljs-attr">startupProbe:</span> <span class="hljs-comment"># Onde definimos a nossa probe de inicialização</span>
          <span class="hljs-attr">httpGet:</span> <span class="hljs-comment"># O tipo de teste que iremos executar, neste caso, iremos executar um teste HTTP</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># O caminho que iremos testar</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># A porta que iremos testar</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># O tempo que iremos esperar para executar a primeira vez a probe</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># De quanto em quanto tempo iremos executar a probe</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># O tempo que iremos esperar para considerar que a probe falhou</span>
          <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># O número de vezes que a probe precisa passar para considerar que o container está pronto</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># O número de vezes que a probe precisa falhar para considerar que o container não está pronto</span>
</code></pre>
<p> </p>
<p>Agora vamos aplicar novamente:</p>
<pre><code class="lang-bash">kubectl apply -f nginx-startup.yaml
</code></pre>
<p> </p>
<p>Pronto, aplicado! Ufa! \o/</p>
<p>Perceba que sua definição é super parecida com a <code>readinessProbe</code>, mas lembre-se, ela somente será executada uma vez, quando o container for inicializado. Portanto, se alguma coisa acontecer de errado depois disso, ele não irá te salvar, pois ele não irá executar novamente.</p>
<p>Por isso é super importante sempre ter uma combinação entre as probes, para que você tenha um container mais resiliente e que problemas possam ser detectados mais rapidamente.</p>
<p>Vamos ver se os nossos <code>Pods</code> estão saudáveis:</p>
<pre><code class="lang-bash">NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-6fbd5f9794-66sww   1/1     Running   0          2m12s
nginx-deployment-6fbd5f9794-cmwq8   1/1     Running   0          2m12s
nginx-deployment-6fbd5f9794-kvrp8   1/1     Running   0          2m12s
</code></pre>
<p> </p>
<p>Caso você queira conferir se a nossa probe está lá, basta usar o comando:</p>
<pre><code class="lang-bash">kubectl describe pod nginx-deployment-6fbd5f9794-66sww
</code></pre>
<p> </p>
<p>E você verá algo parecido com isso:</p>
<pre><code class="lang-bash">    Startup:      http-get http://:80/ delay=10s timeout=5s period=10s <span class="hljs-comment">#success=1 #failure=1</span>
</code></pre>
<p> </p>
<h3 id="exemplo-com-todas-as-probes">Exemplo com todas as probes</h3>
<p>Vamos para o nosso exemplo final de hoje, vamos utilizar todas as probes que vimos até aqui, e vamos criar um arquivo chamado <code>nginx-todas-probes.yaml</code>:</p>
<pre><code class="lang-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
  <span class="hljs-attr">strategy:</span> {}
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-deployment</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.19.2</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
        <span class="hljs-attr">resources:</span>
          <span class="hljs-attr">limits:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">256Mi</span>
          <span class="hljs-attr">requests:</span>
            <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.25</span>
            <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span>
        <span class="hljs-attr">livenessProbe:</span> <span class="hljs-comment"># Onde definimos a nossa probe de vida</span>
          <span class="hljs-attr">exec:</span> <span class="hljs-comment"># O tipo exec é utilizado quando queremos executar algo dentro do container.</span>
            <span class="hljs-attr">command:</span> <span class="hljs-comment"># Onde iremos definir qual comando iremos executar</span>
              <span class="hljs-bullet">-</span> <span class="hljs-string">curl</span>
              <span class="hljs-bullet">-</span> <span class="hljs-string">-f</span>
              <span class="hljs-bullet">-</span> <span class="hljs-string">http://localhost:80/</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># O tempo que iremos esperar para executar a primeira vez a probe</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># De quanto em quanto tempo iremos executar a probe</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># O tempo que iremos esperar para considerar que a probe falhou</span>
          <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># O número de vezes que a probe precisa passar para considerar que o container está pronto</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># O número de vezes que a probe precisa falhar para considerar que o container não está pronto</span>
        <span class="hljs-attr">readinessProbe:</span> <span class="hljs-comment"># Onde definimos a nossa probe de prontidão</span>
          <span class="hljs-attr">httpGet:</span> <span class="hljs-comment"># O tipo de teste que iremos executar, neste caso, iremos executar um teste HTTP</span>
            <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># O caminho que iremos testar</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># A porta que iremos testar</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># O tempo que iremos esperar para executar a primeira vez a probe</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># De quanto em quanto tempo iremos executar a probe</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># O tempo que iremos esperar para considerar que a probe falhou</span>
          <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># O número de vezes que a probe precisa passar para considerar que o container está pronto</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># O número de vezes que a probe precisa falhar para considerar que o container não está pronto</span>
        <span class="hljs-attr">startupProbe:</span> <span class="hljs-comment"># Onde definimos a nossa probe de inicialização</span>
          <span class="hljs-attr">tcpSocket:</span> <span class="hljs-comment"># O tipo de teste que iremos executar, neste caso, iremos executar um teste TCP</span>
            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># A porta que iremos testar</span>
          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># O tempo que iremos esperar para executar a primeira vez a probe</span>
          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># De quanto em quanto tempo iremos executar a probe</span>
          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># O tempo que iremos esperar para considerar que a probe falhou</span>
          <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># O número de vezes que a probe precisa passar para considerar que o container está pronto</span>
          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># O número de vezes que a probe precisa falhar para considerar que o container não está pronto</span>
</code></pre>
<p> </p>
<p>Pronto, estamos utilizando as três probes, vamos aplicar:</p>
<pre><code class="lang-bash">kubectl apply -f nginx-todas-probes.yaml
</code></pre>
<p> </p>
<p>E vamos ver se os nossos <code>Pods</code> estão saudáveis:</p>
<pre><code class="lang-bash">

</code></pre>
<p> </p>
<p>Vamos ver na saída do <code>describe pods</code> se as nossa probes estão por lá.</p>
<pre><code class="lang-bash">...
    Liveness:     <span class="hljs-built_in">exec</span> [curl -f http://localhost:80/] delay=10s timeout=5s period=10s <span class="hljs-comment">#success=1 #failure=3</span>
    Readiness:    http-get http://:80/ delay=10s timeout=5s period=10s <span class="hljs-comment">#success=1 #failure=3</span>
    Startup:      tcp-socket :80 delay=10s timeout=5s period=10s <span class="hljs-comment">#success=1 #failure=3</span>
</code></pre>
<p> </p>
<p>Todas lá! Maravilha!</p>
<p>Agora podemos dizer que já sabemos como cuidar bem dos nossos <code>Pods</code> e deixá-los sempre saudáveis e no controle.</p>
<p>Não esqueça de acessar a documentação oficial do Kubernetes para saber mais sobre as probes, e claro, se tiver alguma dúvida, não deixe de perguntar.</p>
<p> </p>
<h3 id="a-sua-lição-de-casa">A sua lição de casa</h3>
<p>A sua lição de casa é treinar tudo o que você aprendeu até aqui. O mais importante é você replicar todo o conteúdo que foi apresentado até aqui, para que você possa fixar, e o mais importante, deixar isso de forma mais natural na sua cabeça.</p>
<p>Crie seus exemplos, leia a documentação, faça perguntas, e claro, se tiver alguma dúvida, não deixe de perguntar.</p>
<p>Tudo o que você criar daqui pra frente, terá que ter as probes definidas para garantir um bom funcionamento do seu cluster.</p>
<p>Sem falar que é inadmissível você ter um cluster Kubernetes com seus <code>pods</code> rodando sem as probes devidamente configuradas, bem como os limites de recursos.</p>
<p>É isso, simples assim! :D</p>
<p> </p>
<h3 id="final-do-day-4">Final do Day-4</h3>
<p>Durante o Day-4 você aprendeu tudo sobre <code>ReplicaSet</code> e <code>DaemonSet</code>. O dia de hoje foi importante para que você pudesse entender que um cluster Kubernetes é muito mais do que somente um monte de <code>Pods</code> rodando em um monte de <code>nodes</code>. E ainda estamos somente no ínicio da nossa jornada, ainda veremos diversos, talvez dezenas de objetos que irão nos ajudar a gerenciar o nosso cluster de maneira mais efetiva.</p>
<p>Hoje ainda você aprendeu como garantir testes em seus containers, seja no momento da inicialização, ou durante a execução, fazendo com que nossas aplicações sejam mais estáveis e confiáveis.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../day-3/" class="navigation navigation-prev " aria-label="Previous page: Descomplicando Kubernetes dia 3">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../day-5/" class="navigation navigation-next " aria-label="Next page: Descomplicando Kubernetes dia 5">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Descomplicando Kubernetes dia 4","level":"2.4","depth":1,"next":{"title":"Descomplicando Kubernetes dia 5","level":"2.5","depth":1,"path":"day-5/README.md","ref":"day-5/README.md","articles":[]},"previous":{"title":"Descomplicando Kubernetes dia 3","level":"2.3","depth":1,"path":"day-3/README.md","ref":"day-3/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"pt","gitbook":"*"},"file":{"path":"day-4/README.md","mtime":"2024-01-28T18:15:53.885Z","type":"markdown"},"gitbook":{"version":"3.6.20","time":"2024-01-28T18:16:01.670Z"},"basePath":"..","book":{"language":"pt"}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

